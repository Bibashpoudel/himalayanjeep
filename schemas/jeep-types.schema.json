{
  "type": "object",
  "properties": {
    "createdAt": {
      "type": "number"
    },
    "updatedAt": {
      "type": "number"
    },
    "deletedAt": {
      "$ref": "#/definitions/DeletedAt"
    },
    "createdFirstAt": {
      "$ref": "#/definitions/CreatedFirstAt"
    },
    "operationName": {
      "type": [
        "null",
        "string"
      ],
      "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
    },
    "projectRelativePath": {
      "type": "string",
      "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
    },
    "operationRelativePath": {
      "type": "string",
      "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
    },
    "id": {
      "type": "string"
    },
    "categoryStackCalculated": {
      "$ref": "#/definitions/CategoryStack",
      "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
    },
    "amountSeatsLeft": {
      "type": "number",
      "description": "passenger seats left inside the jeep"
    },
    "amountLuggageUnitsLeft": {
      "type": "number",
      "description": "m3 of luggage left"
    },
    "note": {
      "type": "string",
      "description": "note that the driver can set"
    },
    "locationsCalculated": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/LocationType"
      }
    },
    "name": {
      "type": "string"
    },
    "email": {
      "type": "string"
    },
    "phone": {
      "type": "string",
      "description": "mobile phone number"
    },
    "numberPlate": {
      "type": "string",
      "description": "inputted by admin"
    },
    "licenseNumber": {
      "type": "string",
      "description": "inputted by admin\n\n(verify that the jeep is real)"
    },
    "citizenshipNumber": {
      "type": "string",
      "description": "inputted by admin"
    },
    "isVerified": {
      "type": "boolean",
      "description": "inputted by admin"
    },
    "citizenshipImage": {
      "$ref": "#/definitions/BackendAsset"
    },
    "driverLicenseImage": {
      "$ref": "#/definitions/BackendAsset"
    },
    "loginToken": {
      "type": "string"
    },
    "encrypedPassword": {
      "type": "string"
    }
  },
  "required": [
    "amountLuggageUnitsLeft",
    "amountSeatsLeft",
    "createdAt",
    "createdFirstAt",
    "deletedAt",
    "encrypedPassword",
    "id",
    "isVerified",
    "loginToken",
    "name",
    "note",
    "operationName",
    "projectRelativePath",
    "updatedAt"
  ],
  "additionalProperties": false,
  "description": "Everyting about the jeep, in the model...",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "JeepType",
  "definitions": {
    "NamedParameters%3Ctypeof executeFunction%3E": {
      "type": "object",
      "properties": {
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        }
      },
      "required": [
        "tsFunction"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof runFunctionServer%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "RunEveryPeriodEnum": {
      "type": "string",
      "enum": [
        "minute",
        "5-minutes",
        "quarter-hour",
        "hour",
        "6-hours",
        "midnight",
        "week",
        "month",
        "3-months",
        "year"
      ],
      "description": "Used to specify functions that need to run every time with a specific interval\n\nAll times are at at the server timezone time\n\n- `minute`: every minute at 0 seconds\n- `5-mintues`: every 5 minutes, starting at the first minute of the hour\n- `quarter-hour`: every 15 minutes, starting at the first minute of the hour\n- `hour`: every hour, starting at the first minute of the hour\n- `6-hours`: every 6 hours, starting at midnight\n- `midnight`: every midnight (00:00:00)\n- `week`: every week at sundaynight (sunday, 1 second after 23:59:59 PM)\n- `month`: at the first second of the first day of the month (0:00:00)\n- `3-months`: every start of the quarter: january 1st (0:00:00), april 1st, july 1st, october 1st\n- `year`: every new year at january 1st at 0:00:00"
    },
    "TsFunction": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "canCache": {
          "type": "boolean",
          "description": "whether or not the function is can be cached (relies on cache invalidation)"
        },
        "isGetApi": {
          "type": "boolean",
          "description": "if true, the function will get the `server`.js context as its only argument, and it's directly exposed as GET api. Endpoint path will be inferred from the function name\n\nFor this to be indexed to `true`, you need to call the function `abcXyzGetApi` whhere `abcXyz` can be anything."
        },
        "isPostApi": {
          "type": "boolean",
          "description": "If true, the function will get the `server`.js context as its only argument, and it's directly exposed as POST api. Endpoint path will be inferred from the function name\n\nFor this to be indexed to `true`, you need to call the function `abcXyzPostApi` where `abcXyz` can be anything."
        },
        "isExported": {
          "type": "boolean",
          "description": "The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation"
        },
        "isApiExposed": {
          "type": "boolean",
          "description": "for all exported functions in node operations, true by default false for others\n\ncan be overwritten using frontmatter"
        },
        "publicAuthorization": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthorizationLevel"
          },
          "description": "The default authorization that is set level applies to users without any specific authorization (granted to everyone).\n\nshould be indexed based on doccomment containing `AUTH-PUBLIC: [execute], [read], [search]`"
        },
        "runEveryPeriod": {
          "$ref": "#/definitions/RunEveryPeriodEnum",
          "description": "You can specify `runEveryPeriod` in your frontmatter of a function. This will set `runEveryPeriod` for the TsFunction. This is used by `function-server`: it will execute CRON-jobs that run these things on those periods.\n\nWill only work if the function takes no arguments."
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "parsed comment from doc-comment"
        },
        "rawText": {
          "type": "string",
          "description": "raw text of the function"
        },
        "commentsInside": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          },
          "description": "all comments found in a function and the node that they belong to"
        },
        "returnType": {
          "$ref": "#/definitions/TypeInfo",
          "description": "return type JSON Schema definition"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FunctionParameter"
          },
          "description": "parameters the function takes as its arguments, if any"
        },
        "size": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of this function (comments + code)"
        },
        "commentSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of the comments of this function (including surrounding comments)"
        },
        "codeSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of the code inside the function (without comments)"
        },
        "cumulativeSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "tells you the size of itself and all its dependencies that are used that are also part of an operation, recursively"
        },
        "cumulativeCommentSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "cumulativeCodeSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "maxIndentationDepth": {
          "type": "number",
          "description": "maximum amount of times indedented in this function\n\ngood for determining the complexity and finding code that can be simplified/destructured into smaller pieces"
        },
        "dependantFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "finds all files that import this function\n\nNB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly."
        }
      },
      "required": [
        "commentsInside",
        "id",
        "isApiExposed",
        "isExported",
        "maxIndentationDepth",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "publicAuthorization",
        "returnType",
        "size",
        "slug"
      ],
      "additionalProperties": false,
      "description": "--- dbStorageMethod: jsonSingle\n---\n\nInterface for arrow functions and normal functions"
    },
    "FunctionParameter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "schema": {
          "$ref": "#/definitions/Schema"
        },
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        },
        "required": {
          "type": "boolean"
        }
      },
      "required": [
        "name",
        "required"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDataParameterNames%3E": {
      "type": "object",
      "properties": {
        "properties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SchemaProperty"
          }
        }
      },
      "required": [
        "properties"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof ModelComponent%3E": {
      "type": "object",
      "properties": {
        "{\n  modelName,\n  highlight,\n}": {
          "type": "object",
          "properties": {
            "modelName": {
              "type": "string"
            },
            "highlight": {
              "type": "object",
              "properties": {
                "slug": {
                  "type": "string"
                },
                "id": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "highlight"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  modelName,\n  highlight,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Page%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof SimplifiedSchemaFormDebug%3E": {
      "type": "object",
      "properties": {
        "{\n  parameters,\n  values,\n}": {
          "type": "object",
          "properties": {
            "parameters": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/FunctionParameter"
              }
            },
            "values": {
              "type": "array",
              "items": {}
            }
          },
          "required": [
            "values"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  parameters,\n  values,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof UpsertForm%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "simplifiedSchema": {
              "$ref": "#/definitions/SimplifiedSchema",
              "description": "the schema for the model we want to update/create"
            },
            "instance": {
              "description": "an instance, if it's an update form"
            },
            "referencableModelNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "NB: this thing will make hooks appear, so it must be constant!"
            },
            "projectRelativeStorageFilePath": {
              "type": "string",
              "description": "Where is the file stored that this form is for? needed for rendering images and uploading images in writer-input"
            }
          },
          "required": [
            "simplifiedSchema",
            "instance",
            "projectRelativeStorageFilePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "SchemaProperty": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "schema": {
          "$ref": "#/definitions/JSONSchema7"
        },
        "required": {
          "type": "boolean"
        }
      },
      "required": [
        "name",
        "schema",
        "required"
      ],
      "additionalProperties": false
    },
    "SimplifiedSchema": {
      "type": "object",
      "properties": {
        "todo": {
          "type": "string"
        },
        "discussion": {
          "type": "string"
        },
        "idea": {
          "type": "string"
        },
        "later": {
          "type": "string"
        },
        "nb": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "section": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/SimplifiedSchemaType",
          "description": "- string\n- number\n- boolean\n- object\n- array\n- null\n\nNB: Omit doesn't work for the indexer! This would be the type: Omit<JSONSchema7TypeName, \"integer\">;"
        },
        "circularRefName": {
          "type": "string",
          "description": "sometimes we still need to reference to another schema because this thing is recursive. In that case the ref name will be here"
        },
        "enum": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONSchema7Type"
          },
          "description": "in case of enums this could appear... mostly strings, but e.g. numbers can also be an enum I think"
        },
        "properties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SimplifiedSchemaProperty"
          },
          "description": "in case of object, this will always appear"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SimplifiedSchemaItem"
          },
          "description": "in case of arrays, this will always appear"
        },
        "fullComment": {
          "type": "string",
          "description": "Full doccomment, parsed without all stars syntax.\n\nNB: besides this, every `CommentType` can optionally also be found as a property on the `SimplifiedSchema`"
        }
      },
      "required": [
        "type"
      ],
      "additionalProperties": false,
      "description": "JSONSchema7 derivative that has the following capabilities and and characteristics...\n\n- does not include objects in objects that are also referenced to using xxxSlug or xxxId\n- recursively finds the references and expands them, unless the references are circular\n- easier to read\n- has all the information we need\n- is able to generate an object with values in the exact format the function needs it\n- is able to easily generate a form"
    },
    "NamedParameters%3Ctypeof driverLogin%3E": {
      "type": "object",
      "properties": {
        "emailOrPhone": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "required": [
        "emailOrPhone",
        "password"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof driverSignup%3E": {
      "type": "object",
      "properties": {
        "driverInfo": {
          "$ref": "#/definitions/SignupJeepType"
        }
      },
      "required": [
        "driverInfo"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMyJeep%3E": {
      "type": "object",
      "properties": {
        "loginToken": {
          "type": "string"
        }
      },
      "required": [
        "loginToken"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof updateMyProfile%3E": {
      "type": "object",
      "properties": {
        "loginToken": {
          "type": "string"
        },
        "myJeep": {
          "type": "object",
          "properties": {
            "citizenshipImage": {
              "$ref": "#/definitions/BackendAsset"
            },
            "driverLicenseImage": {
              "$ref": "#/definitions/BackendAsset"
            },
            "amountSeatsLeft": {
              "type": "number",
              "description": "passenger seats left inside the jeep"
            },
            "amountLuggageUnitsLeft": {
              "type": "number",
              "description": "m3 of luggage left"
            },
            "note": {
              "type": "string",
              "description": "note that the driver can set"
            },
            "locationsCalculated": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/LocationType"
              }
            },
            "name": {
              "type": "string"
            },
            "email": {
              "type": "string"
            },
            "phone": {
              "type": "string",
              "description": "mobile phone number"
            }
          },
          "required": [
            "amountSeatsLeft",
            "amountLuggageUnitsLeft",
            "note",
            "name"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "loginToken",
        "myJeep"
      ],
      "additionalProperties": false
    },
    "SignupJeepType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "phone": {
          "type": "string",
          "description": "mobile phone number"
        },
        "password": {
          "type": "string"
        },
        "repeatPassword": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "password",
        "repeatPassword"
      ],
      "additionalProperties": false,
      "description": "Jeep driver signup FORM (not part of the model)"
    },
    "AdminLoginType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "phone": {
          "type": "string",
          "description": "mobile phone number"
        },
        "password": {
          "type": "string"
        },
        "repeatPassword": {
          "type": "string"
        },
        "createdAt": {
          "type": "number"
        },
        "updatedAt": {
          "type": "number"
        }
      },
      "required": [
        "name",
        "password",
        "repeatPassword",
        "createdAt",
        "updatedAt"
      ],
      "additionalProperties": false
    },
    "BackendAsset": {
      "type": "object",
      "properties": {
        "alt": {
          "type": "string",
          "description": "Stored value\n\nAlt text for the asset"
        },
        "relativePath": {
          "type": "string",
          "description": "Stored value\n\nRelative path, relative to the location the asset is defined in.\n\nOnly available if the asset was already processed by a backend. Before backend processing, only `temporaryDestination` is available.\n\nChanging the `relativePath` shouldn't do anything, it can only be changed by backend processing by giving a new `temporaryDestination`, or by changing the `name`."
        },
        "name": {
          "type": "string",
          "description": "Not stored\n\nNot given by the backend data, but can be SENT to the backend.\n\nShould not be stored, but if you change this value and send it to the backend, it should rename the file and thus the relativePath stored should change.\n\nNB: I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!"
        },
        "temporaryDestination": {
          "type": "string",
          "description": "Not stored\n\n\nFilename after uploading in the temporary folder. should still be moved to its final location\n\nOnly available straight after uploading. After the function processes the asset, this is removed and a `relativePath` is created."
        }
      },
      "additionalProperties": false,
      "description": "Part of the asset that should be sent to the backend. The rest should frontend-only\n\nSome values are stored, some are not"
    },
    "DefaultModelType": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ],
      "description": "Use this model by default"
    },
    "LocationType": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "jeepId": {
          "type": "string"
        },
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        },
        "nearbyVillage": {
          "type": "string",
          "description": "calculate the most nearby village based on the hardcoded village location data we have for all villages in nepal."
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "jeepId",
        "latitude",
        "longitude",
        "nearbyVillage",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Jeep location"
    },
    "MyJeepAdminTypes": {
      "type": "object",
      "properties": {
        "numberPlate": {
          "type": "string",
          "description": "inputted by admin"
        },
        "licenseNumber": {
          "type": "string",
          "description": "inputted by admin\n\n(verify that the jeep is real)"
        },
        "citizenshipNumber": {
          "type": "string",
          "description": "inputted by admin"
        },
        "isVerified": {
          "type": "boolean",
          "description": "inputted by admin"
        }
      },
      "required": [
        "isVerified"
      ],
      "additionalProperties": false
    },
    "MyJeepType": {
      "type": "object",
      "properties": {
        "numberPlate": {
          "type": "string",
          "description": "inputted by admin"
        },
        "licenseNumber": {
          "type": "string",
          "description": "inputted by admin\n\n(verify that the jeep is real)"
        },
        "citizenshipNumber": {
          "type": "string",
          "description": "inputted by admin"
        },
        "isVerified": {
          "type": "boolean",
          "description": "inputted by admin"
        },
        "id": {
          "type": "string"
        },
        "amountSeatsLeft": {
          "type": "number",
          "description": "passenger seats left inside the jeep"
        },
        "amountLuggageUnitsLeft": {
          "type": "number",
          "description": "m3 of luggage left"
        },
        "note": {
          "type": "string",
          "description": "note that the driver can set"
        },
        "locationsCalculated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LocationType"
          }
        },
        "name": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "phone": {
          "type": "string",
          "description": "mobile phone number"
        },
        "createdAt": {
          "type": "number"
        },
        "updatedAt": {
          "type": "number"
        },
        "citizenshipImage": {
          "$ref": "#/definitions/BackendAsset"
        },
        "driverLicenseImage": {
          "$ref": "#/definitions/BackendAsset"
        }
      },
      "additionalProperties": false,
      "required": [
        "amountLuggageUnitsLeft",
        "amountSeatsLeft",
        "createdAt",
        "id",
        "isVerified",
        "name",
        "note",
        "updatedAt"
      ],
      "description": "Driver login jeep info\n\nwill be returned when you request your own information (when logged in)"
    },
    "PublicJeepType": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "amountSeatsLeft": {
          "type": "number",
          "description": "passenger seats left inside the jeep"
        },
        "amountLuggageUnitsLeft": {
          "type": "number",
          "description": "m3 of luggage left"
        },
        "note": {
          "type": "string",
          "description": "note that the driver can set"
        },
        "locationsCalculated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LocationType"
          }
        },
        "name": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "phone": {
          "type": "string",
          "description": "mobile phone number"
        },
        "createdAt": {
          "type": "number"
        },
        "updatedAt": {
          "type": "number"
        }
      },
      "required": [
        "id",
        "amountSeatsLeft",
        "amountLuggageUnitsLeft",
        "note",
        "name",
        "createdAt",
        "updatedAt"
      ],
      "additionalProperties": false,
      "description": "Passenger public jeep overview"
    },
    "MarkdownReaderPage": {
      "type": "object",
      "properties": {
        "queryPath": {
          "type": "string",
          "description": "path to be used as the url. no preceding slash"
        },
        "filePath": {
          "type": "string",
          "description": "if given, the md-file will be provided to the frontend\n\nproject relative path"
        },
        "isMenuItem": {
          "type": "boolean",
          "description": "if true, this item will be shown in the menu"
        }
      },
      "required": [
        "queryPath"
      ],
      "additionalProperties": false,
      "description": "for markdown-reader-ui, the pages can be markdown files, but they can also be connected to models"
    },
    "NamedParameters%3Ctypeof getQueryPath%3E": {
      "type": "object",
      "properties": {
        "parsedUrlQuery": {
          "$ref": "#/definitions/NextParsedUrlQuery"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Layout%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "publicBundleConfig": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "categoryStackCalculated": {
                      "$ref": "#/definitions/CategoryStack",
                      "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
                    },
                    "id": {
                      "$ref": "#/definitions/Id"
                    },
                    "operationName": {
                      "type": [
                        "null",
                        "string"
                      ],
                      "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
                    },
                    "projectRelativePath": {
                      "type": "string",
                      "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
                    },
                    "operationRelativePath": {
                      "type": "string",
                      "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
                    },
                    "createdAt": {
                      "$ref": "#/definitions/CreatedAt"
                    },
                    "updatedAt": {
                      "$ref": "#/definitions/UpdatedAt"
                    },
                    "deletedAt": {
                      "$ref": "#/definitions/DeletedAt"
                    },
                    "createdFirstAt": {
                      "$ref": "#/definitions/CreatedFirstAt"
                    },
                    "slug": {
                      "$ref": "#/definitions/Id"
                    },
                    "name": {
                      "$ref": "#/definitions/Id"
                    },
                    "language": {
                      "$ref": "#/definitions/Id"
                    },
                    "description": {
                      "$ref": "#/definitions/Id"
                    },
                    "emoji": {
                      "$ref": "#/definitions/Id"
                    },
                    "primaryColor": {
                      "$ref": "#/definitions/Id"
                    },
                    "gitRepoUrl": {
                      "$ref": "#/definitions/Id"
                    },
                    "isGitRepoPublic": {
                      "$ref": "#/definitions/Id"
                    },
                    "bundleMarkdownReaderConfig": {
                      "$ref": "#/definitions/Id"
                    }
                  },
                  "required": [
                    "id",
                    "operationName",
                    "projectRelativePath",
                    "createdAt",
                    "updatedAt",
                    "deletedAt",
                    "createdFirstAt"
                  ],
                  "additionalProperties": false
                },
                {
                  "type": "null"
                }
              ]
            },
            "pages": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/MarkdownReaderPage"
              }
            },
            "children": {},
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            }
          },
          "required": [
            "pages",
            "children"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NextParsedUrlQuery": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "array"
            ]
          }
        ]
      },
      "properties": {
        "amp": {
          "type": "string",
          "const": "1"
        },
        "__nextNotFoundSrcPage": {
          "type": "string"
        },
        "__nextDefaultLocale": {
          "type": "string"
        },
        "__nextFallback": {
          "type": "string",
          "const": "true"
        },
        "__nextLocale": {
          "type": "string"
        },
        "__nextSsgPath": {
          "type": "string"
        },
        "_nextBubbleNoFallback": {
          "type": "string",
          "const": "1"
        },
        "_nextDataReq": {
          "type": "string",
          "const": "1"
        }
      }
    },
    "AugmentedWord": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/AugmentedWordTypeEnum"
        },
        "word": {
          "type": "string",
          "description": "Word without affixes. The affixes will be decided in the frontend parser based on the type"
        },
        "queryPath": {
          "type": "string"
        },
        "projectRelativeMarkdownSourcePath": {
          "type": "string"
        },
        "spoiler": {
          "type": "string"
        },
        "isCaseInsensitive": {
          "type": "boolean",
          "description": "If true, will match on lowercase variant of the word"
        }
      },
      "required": [
        "type",
        "word",
        "projectRelativeMarkdownSourcePath"
      ],
      "additionalProperties": false,
      "description": "AugmentedWords should have a small footprint since there can be many of them\n\nWords with a specific affix (backticks, bolded, italic) will match against these.\n\nUsed to link automatically to functionNames, InterfaceNames, operation-names, words, and more.."
    },
    "NamedParameters%3Ctypeof AugmentedWordComponent%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "augmentedWord": {
              "$ref": "#/definitions/AugmentedWord"
            },
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            }
          },
          "required": [
            "augmentedWord",
            "augmentedWordObject"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Dictionary%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            },
            "word": {
              "type": "string"
            }
          },
          "required": [
            "augmentedWordObject"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Search%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AugmentedWord"
              }
            }
          },
          "required": [
            "results"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof allOperationsRemoveJsSrc%3E": {
      "type": "object",
      "properties": {
        "debug": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof allOperationsToMarkdown%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof clearAllTsDatabases%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof codeAll%3E": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string"
        }
      },
      "required": [
        "search"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllOperationClassifications%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mdAllOperations%3E": {
      "type": "object",
      "properties": {
        "debug": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof minifyAllOperations%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "basePath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "onlyRoot": {
              "type": "boolean"
            },
            "shell": {
              "type": "boolean",
              "description": "if you run a command, setting this to true, will make sure the results are shown"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeAllFiles%3E": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string"
        }
      },
      "required": [
        "search"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeAllFolders%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "basePath": {
              "type": "string"
            },
            "folderNames": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ignore": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "onlyRoot": {
              "type": "boolean"
            }
          },
          "required": [
            "basePath",
            "folderNames"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeAllFoldersCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof runScriptEverywhere%3E": {
      "type": "object",
      "properties": {
        "script": {
          "type": "string"
        },
        "startIndex": {
          "type": "number"
        }
      },
      "required": [
        "script"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof setScriptEverywhere%3E": {
      "type": "object",
      "properties": {
        "script": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "required": [
        "script",
        "value"
      ],
      "additionalProperties": false
    },
    "ApiConfig": {
      "type": "object",
      "properties": {
        "apiUrl": {
          "type": "string",
          "description": "optionally provide an api URL (uses sdk-env-public key if not provded)"
        },
        "authToken": {
          "type": "string",
          "description": "optionally provide an authtoken (uses storage key if not provided)"
        },
        "timeout": {
          "type": "number",
          "description": "optionally provide a max ms to execute the api fetch"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof fn1%3E": {
      "type": "object",
      "properties": {
        "a": {
          "type": "string"
        },
        "b": {
          "type": "number"
        }
      },
      "required": [
        "a",
        "b"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof fn2%3E": {
      "type": "object",
      "properties": {
        "a": {
          "type": "string"
        },
        "b": {
          "type": "number"
        }
      },
      "required": [
        "a",
        "b"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof fn3%3E": {
      "type": "object",
      "properties": {
        "a": {
          "type": "string"
        },
        "b": {
          "type": "number"
        }
      },
      "required": [
        "a",
        "b"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getGetApiUrl%3E": {
      "type": "object",
      "properties": {
        "apiUrl": {
          "type": "string"
        },
        "apiFunctionName": {
          "type": "string"
        },
        "query": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "string"
              },
              {
                "not": {}
              }
            ]
          }
        }
      },
      "required": [
        "apiUrl",
        "apiFunctionName",
        "query"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof untypedApiFunction%3E": {
      "type": "object",
      "properties": {
        "fnName": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/ApiConfig"
        },
        "parameters": {}
      },
      "required": [
        "fnName",
        "config",
        "parameters"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof ask%3E": {
      "type": "object",
      "properties": {
        "question": {
          "type": "string"
        }
      },
      "required": [
        "question"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof askOk%3E": {
      "type": "object",
      "properties": {
        "question": {
          "type": "string"
        }
      },
      "required": [
        "question"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getArgumentOrAsk%3E": {
      "type": "object",
      "properties": {
        "argumentPosition": {
          "type": "number"
        },
        "question": {
          "type": "string"
        },
        "isNonInteractive": {
          "type": "boolean"
        }
      },
      "required": [
        "argumentPosition",
        "question"
      ],
      "additionalProperties": false
    },
    "Asset": {
      "type": "object",
      "properties": {
        "alt": {
          "type": "string",
          "description": "Stored value\n\nAlt text for the asset"
        },
        "relativePath": {
          "type": "string",
          "description": "Stored value\n\nRelative path, relative to the location the asset is defined in.\n\nOnly available if the asset was already processed by a backend. Before backend processing, only `temporaryDestination` is available.\n\nChanging the `relativePath` shouldn't do anything, it can only be changed by backend processing by giving a new `temporaryDestination`, or by changing the `name`."
        },
        "name": {
          "type": "string",
          "description": "Not stored\n\nNot given by the backend data, but can be SENT to the backend.\n\nShould not be stored, but if you change this value and send it to the backend, it should rename the file and thus the relativePath stored should change.\n\nNB: I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!"
        },
        "temporaryDestination": {
          "type": "string",
          "description": "Not stored\n\n\nFilename after uploading in the temporary folder. should still be moved to its final location\n\nOnly available straight after uploading. After the function processes the asset, this is removed and a `relativePath` is created."
        },
        "blobPath": {
          "type": "string",
          "description": "path to the local blob if uploading"
        },
        "type": {
          "$ref": "#/definitions/AssetType",
          "description": "can be calculated from the path, or come directly from the blob"
        },
        "originalFilename": {
          "type": "string",
          "description": "if the file was selected from the system, this should be the original filename, including extension"
        },
        "sizeBytes": {
          "type": "number",
          "description": "can be calculated from the file stats."
        },
        "blob": {
          "type": "object",
          "properties": {
            "size": {
              "type": "number"
            },
            "type": {
              "type": "string"
            }
          },
          "required": [
            "size",
            "type"
          ],
          "additionalProperties": false,
          "description": "Blob that is available after selecting from the local file system"
        },
        "uploadProgress": {
          "type": "number",
          "description": "number between 0 and 1 indicating uploadProgress"
        }
      },
      "additionalProperties": false,
      "description": "Asset you can upload\n\nThis is not a database model, it can exist in properties of any db model or type interface.\n\nOnly `alt` and `relativePath` are stored, the other parameters are optionally required for uploading and user interfaces, and are not always there\n\nNB: don't use this in your model, use `StoredAsset` instead."
    },
    "NamedParameters%3Ctypeof addToken%3E": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "previousToken": {
          "type": "string",
          "description": "if given, uses this token, otherwise generates a new random token"
        },
        "attachTokenToFilename": {
          "type": "boolean"
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof ensureToken%3E": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "newToken": {
          "type": "string",
          "description": "if given, is used for generating new token\n\nif already present, token is used from the name instead of this one"
        },
        "attachTokenToFilename": {
          "type": "boolean"
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAssetDirectlyApiUrl%3E": {
      "type": "object",
      "properties": {
        "apiUrl": {
          "type": "string"
        },
        "projectRelativeAssetPath": {
          "type": "string"
        }
      },
      "required": [
        "apiUrl",
        "projectRelativeAssetPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getExtensionFromAsset%3E": {
      "type": "object",
      "properties": {
        "asset": {
          "$ref": "#/definitions/Asset"
        }
      },
      "required": [
        "asset"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNameFromRelativePath%3E": {
      "type": "object",
      "properties": {
        "relativePath": {
          "type": "string"
        }
      },
      "required": [
        "relativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNameWithTokenFromRelativePath%3E": {
      "type": "object",
      "properties": {
        "relativePath": {
          "type": "string"
        },
        "attachTokenToFilename": {
          "type": "boolean"
        },
        "newToken": {
          "type": "string"
        }
      },
      "required": [
        "relativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPreferredExtensionFromType%3E": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getReferencedAssetApiUrl%3E": {
      "type": "object",
      "properties": {
        "apiUrl": {
          "type": "string"
        },
        "projectRelativeReferencingFilePath": {
          "type": "string"
        },
        "referencingFileRelativeAssetPath": {
          "type": "string"
        },
        "isDownload": {
          "type": "boolean",
          "description": "If true, asset will be returned as download"
        }
      },
      "required": [
        "apiUrl",
        "projectRelativeReferencingFilePath",
        "referencingFileRelativeAssetPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTypeFromRelativePath%3E": {
      "type": "object",
      "properties": {
        "relativePath": {
          "type": "string"
        }
      },
      "required": [
        "relativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readableSize%3E": {
      "type": "object",
      "properties": {
        "sizeBytes": {
          "type": "number"
        }
      },
      "required": [
        "sizeBytes"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeTokenIfPresent%3E": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "attachTokenToFilename": {
          "type": "boolean"
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    },
    "AssetInputType": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "image",
            "video",
            "audio",
            "file",
            "asset"
          ]
        },
        "isMultiple": {
          "type": "boolean"
        }
      },
      "required": [
        "type",
        "isMultiple"
      ],
      "additionalProperties": false
    },
    "AssetParameter": {
      "type": "object",
      "properties": {
        "assetInputType": {
          "$ref": "#/definitions/AssetInputType"
        },
        "parameterName": {
          "type": "string"
        },
        "stack": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "where the object parameter is located"
        }
      },
      "required": [
        "assetInputType",
        "parameterName"
      ],
      "additionalProperties": false
    },
    "CompressionConfig": {
      "type": "object",
      "properties": {
        "bitrate": {
          "type": "number",
          "description": "used for audio"
        },
        "fps": {
          "type": "number",
          "description": "Frames per second. Used for video"
        },
        "resolution": {
          "type": "object",
          "properties": {
            "width": {
              "type": "number"
            },
            "height": {
              "type": "number"
            }
          },
          "required": [
            "width",
            "height"
          ],
          "additionalProperties": false,
          "description": "Set the resolution. Will not upscale.\n\nUsed for video and images"
        },
        "shouldOverwrite": {
          "type": "boolean",
          "description": "if true, will overwrite the original file"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof compressAsset%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        },
        "compressionConfig": {
          "$ref": "#/definitions/CompressionConfig"
        }
      },
      "required": [
        "absolutePath",
        "compressionConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof downloadRemoteAsset%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof convertToMp3%3E": {
      "type": "object",
      "properties": {
        "sourcePath": {
          "type": "string"
        },
        "destinationPath": {
          "type": "string"
        }
      },
      "required": [
        "sourcePath",
        "destinationPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof deleteReferencedAsset%3E": {
      "type": "object",
      "properties": {
        "projectRelativeReferencingFilePath": {
          "type": "string"
        },
        "referencingFileRelativeAssetPath": {
          "type": "string"
        }
      },
      "required": [
        "projectRelativeReferencingFilePath",
        "referencingFileRelativeAssetPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAbsoluteAssetPathFromReference%3E": {
      "type": "object",
      "properties": {
        "projectRelativeReferencingFilePath": {
          "type": "string"
        },
        "referencingFileRelativeAssetPath": {
          "type": "string"
        }
      },
      "required": [
        "projectRelativeReferencingFilePath",
        "referencingFileRelativeAssetPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAllProjectMedia%3E": {
      "type": "object",
      "properties": {
        "searchQuery": {
          "type": "string"
        },
        "returnType": {
          "type": "string",
          "enum": [
            "projectRelative",
            "absolute"
          ],
          "description": "defaults to absolute"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAssetParametersRecursively%3E": {
      "type": "object",
      "properties": {
        "object": {
          "type": "object"
        },
        "stack": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "object"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getStorageLocationInfo%3E": {
      "type": "object",
      "properties": {
        "absoluteReferencingFilePath": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/ProcessAssetConfig"
        }
      },
      "required": [
        "absoluteReferencingFilePath",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTemporaryAssetsFolderPath%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof processAsset%3E": {
      "type": "object",
      "properties": {
        "backendAsset": {
          "$ref": "#/definitions/BackendAsset",
          "description": "The backendAsset that may need processing"
        },
        "absoluteReferencingFilePath": {
          "type": "string",
          "description": "Location of the\n- markdown file (or folder where it is located)\n- typescript file (or folder where it is located)\n- database file (or folder where it is located)"
        },
        "config": {
          "$ref": "#/definitions/ProcessAssetConfig",
          "description": "Extra configuration may somethimes be needed"
        }
      },
      "required": [
        "backendAsset",
        "absoluteReferencingFilePath",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeOldTemporaryAssets%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof serverDownloadReply%3E": {
      "type": "object",
      "properties": {
        "absoluteAssetPath": {
          "type": "string"
        },
        "isDownload": {
          "type": "boolean"
        }
      },
      "required": [
        "absoluteAssetPath",
        "isDownload"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof test%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "ProcessAssetConfig": {
      "type": "object",
      "properties": {
        "modelName": {
          "type": "string",
          "description": "PascalCase model name for database model\n\nOnly needed for database files"
        }
      },
      "additionalProperties": false
    },
    "MediaSourceEnum": {
      "type": "string",
      "enum": [
        "project",
        "p2p",
        "google",
        "giphy",
        "unsplashed",
        "youtube"
      ],
      "description": "project: api urls p2p: api urls with other ip\n--- google: remote image urls giphy: remote image urls unsplashed: remote image urls youtube: remote video urls (selectable as mp3, mp4, or url)"
    },
    "NamedParameters%3Ctypeof getTypeFromFileBlob%3E": {
      "type": "object",
      "properties": {
        "file": {
          "type": "object",
          "properties": {
            "size": {
              "type": "number"
            },
            "type": {
              "type": "string"
            },
            "lastModified": {
              "type": "number"
            },
            "name": {
              "type": "string"
            },
            "webkitRelativePath": {
              "type": "string"
            }
          },
          "required": [
            "lastModified",
            "name",
            "size",
            "type",
            "webkitRelativePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "file"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeBackendAsset%3E": {
      "type": "object",
      "properties": {
        "asset": {
          "$ref": "#/definitions/Asset"
        }
      },
      "required": [
        "asset"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof SelectMedia%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "source": {
              "$ref": "#/definitions/MediaSourceEnum",
              "description": "NB: please don't change the source after initialisation!"
            }
          },
          "required": [
            "source"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "video",
        "audio",
        "image",
        "other"
      ],
      "description": "Possible Asset Types"
    },
    "CompressionOption": {
      "type": "string",
      "enum": [
        "custom",
        "none",
        "default",
        "tiny",
        "big"
      ],
      "description": "CompressionOption should be able to be applied on the model parameter through frontmatter\n\n- default (default option): Default King OS wide compression. User can make customize it within a sensible limit\n- none: no compression applied by default (user can optionally compress it)\n- high: compressed bigtime by default (user cannot make it be compressed less)\n- low: compressed just a little (user cannot make it be compressed less, but can optionally compress it more)"
    },
    "Image": {
      "type": "object",
      "properties": {
        "projectRelativePath": {
          "type": "string",
          "description": "relative path to where the image is stored in the OS\n\nthere should be a function later, that formats that to an URL that is accessible from the internet, if any"
        },
        "width": {
          "type": "number"
        },
        "height": {
          "type": "number"
        },
        "base64": {
          "type": "string",
          "description": "small base64 generated for this image"
        },
        "caption": {
          "type": "string",
          "description": "caption that can be provided for this image\n\nif not given, it can either be auto-generated by AI or it can be based on the model the image is attached to."
        }
      },
      "required": [
        "projectRelativePath",
        "width",
        "height",
        "base64",
        "caption"
      ],
      "additionalProperties": false
    },
    "NewAssetType": {
      "type": "string",
      "enum": [
        "google-images",
        "giphy",
        "unsplashed",
        "youtube",
        "project-media",
        "p2p-media",
        "files",
        "camera",
        "recordAudio",
        "recordVideo",
        "recordScreen"
      ],
      "description": "Possible types for new asset upload in the frontend"
    },
    "UploadAssetBody": {
      "type": "object",
      "properties": {
        "authToken": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "description": "NB: other things like alt, final destination etc, should not be sent with the upload, but instead with the function"
    },
    "UploadAssetResult": {
      "type": "object",
      "properties": {
        "isSuccessful": {
          "type": "boolean"
        },
        "isUnauthorized": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        },
        "temporaryDestination": {
          "type": "string"
        }
      },
      "required": [
        "isSuccessful"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof AssetView%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "asset": {
              "$ref": "#/definitions/Asset"
            },
            "className": {
              "type": "string"
            },
            "projectRelativeReferencingFilePath": {
              "type": "string"
            },
            "hideDownloadLink": {
              "type": "boolean"
            }
          },
          "required": [
            "asset",
            "projectRelativeReferencingFilePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAugmentedWordObject%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAugmentedWords%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getBundleAugmentedWords%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "Authorization": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "TsFunction",
            "TsVarialbe",
            "TsInterface",
            "Dataset",
            "operationName",
            "fileOrFolderPath"
          ],
          "description": "What should be authorized?"
        },
        "value": {
          "type": "string",
          "description": "fileOrFolderPath: project relative path string\n\noperationName: name of the operation (grants access to all models, )\n\notherwise: id of the model"
        },
        "authorizations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthorizationLevel"
          },
          "description": "which things are authorized"
        }
      },
      "required": [
        "type",
        "value",
        "authorizations"
      ],
      "additionalProperties": false
    },
    "AuthorizationLevel": {
      "type": "string",
      "enum": [
        "execute",
        "write-create",
        "write-update",
        "write-delete",
        "read",
        "search"
      ],
      "description": "`AuthorizationLevel` is a single Enum that can apply to privacy and authorization of text, functions, and data.\n\nFor files (ts, md, json, etc...):\n\n- write-create\n- write-update\n- write-delete\n- read\n- search (only search index)\n\nFor db model data subsets:\n\n- write-update\n- write-create\n- write-delete\n- read\n- search (only search index)\n\nFor functions:\n- execute\n\nFor functions, interfaces, variables:\n\n- read (reading docs only. for source, you need to provide the file auth)\n- search (only search index)"
    },
    "NamedParameters%3Ctypeof BreadCrumbs%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderBreadCrumbs%3E": {
      "type": "object",
      "properties": {
        "chunks": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "chunks"
      ],
      "additionalProperties": false
    },
    "AppShell": {
      "type": "string",
      "enum": [
        "web",
        "app",
        "computer",
        "vscode",
        "browser",
        "docusaurus"
      ]
    },
    "BundleConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string",
          "description": "a description about this bundle"
        },
        "emoji": {
          "type": "string"
        },
        "primaryColor": {
          "type": "string"
        },
        "gitRepoUrl": {
          "type": "string",
          "description": "NB: later we may also want to automate the server and frontend deployment setup. for that we need credentials and automation"
        },
        "isGitRepoPublic": {
          "type": "boolean",
          "description": "if true, your gitrepo is marked as pubilc and thus users will be linked to it sometimes"
        },
        "bundleMarkdownReaderConfig": {
          "$ref": "#/definitions/BundleMarkdownReaderConfig",
          "description": "configurate your markdown reader"
        },
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "customisableBundleConfig": {
          "$ref": "#/definitions/CustomisableBundleConfig",
          "description": "CustomisableBundleConfig is customisable for individual bundle creations\n\nNB: This is NOT copied into the bundle itself"
        },
        "createBundleConfig": {
          "$ref": "#/definitions/CreateBundleConfig",
          "description": "Config needed for creating the bundle, not for the bundle itself NB: NOT Copied to the bundle itself"
        }
      },
      "required": [
        "createBundleConfig",
        "createdAt",
        "createdFirstAt",
        "customisableBundleConfig",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "--- dbStorageMethod: jsonSingle\n---\n\nConfiguration options for bundles. Used with `generateBundle`\n\nEverything in this model will be copied over to the created bundle, except for `createBundleConfig` and `customisableBundleConfig`."
    },
    "BundleMarkdownReaderConfig": {
      "type": "object",
      "properties": {
        "docsInRoot": {
          "type": "boolean",
          "description": "When set to `true`, docs are not shown in docs folder but in the root menu of the site"
        },
        "showTodos": {
          "type": "boolean",
          "description": "Show todo menu"
        },
        "omitModulesMenu": {
          "type": "boolean",
          "description": "`modules` will be hidden from markdown reader menu"
        },
        "omitAppsMenu": {
          "type": "boolean",
          "description": "`apps` will be hidden from markdown reader menui"
        },
        "omitDictionaryMenu": {
          "type": "boolean",
          "description": "if true, dictionary is omitted from menu"
        },
        "omitPackagesMenu": {
          "type": "boolean",
          "description": "`packages` will be hidden from markdown reader menu"
        },
        "customOperationNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "if given, the operations menu will show with these operations"
        }
      },
      "additionalProperties": false
    },
    "CreateBundleConfig": {
      "type": "object",
      "properties": {
        "keepStructure": {
          "type": "boolean",
          "description": "If true, the structure of operation locations is kept the same but still inside packages/apps/modules."
        },
        "informationStrategy": {
          "$ref": "#/definitions/InformationStrategy",
          "description": "Default information strategy"
        },
        "modelInformationStrategy": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/InformationStrategy"
          },
          "description": "Information strategy per model\n\nFor example, this would ensure your diaries are not copied over to the bundle:\n\n```json { \"Diary\": \"ignore\" } ```\n\nIf you want to be certain something isn't included, instead of putting it into the model specific information strategy, you can also just put it in an operation that isn't required in the bundle.\n\nThis parameter is especially useful if you want to change a information stategy for one model in specific."
        },
        "additional_datasetSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be added or overwriting the data"
        },
        "filter_datasetSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be found in the then available data in the bundle, and will be filtered out."
        },
        "isDraft": {
          "type": "boolean",
          "description": "If true, this bundleconfig will be skipped when using `generateAllBundles`"
        },
        "keepTodos": {
          "type": "boolean",
          "description": "if true, todos are also copied into their original location, which is in `packages` if it's not in an operation, or in the operation in any of the folders if it's an operation.\n\nThe markdown-reader will then add them to a todo menu.\n\nNB: Only works in conjunction with `keepStructure`"
        },
        "bundles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FrontBackBundle"
          }
        },
        "dependencies": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationPrivacy"
          },
          "description": "Generated, private by default. If they're already here, uses private/public setting as given.\n\nWhen generating, removes the ones that are not dependencies (of dependencies) of your standalone apps"
        },
        "docsRelativeFolderPath": {
          "anyOf": [
            {
              "$ref": "#/definitions/ProjectRelativeFolderPath"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ProjectRelativeFolderPath"
              }
            }
          ],
          "description": "optional. Could also find the main file from here and use that as README.md\n\nMust be a relative path from project root. Can be multiple!"
        },
        "readmeRelativeFilePath": {
          "$ref": "#/definitions/ProjectRelativeFilePath",
          "description": "Optional. path to a readme file for the monorepo root.\n\nIf not given, and if you did provide a path for docs, the main docs intro file will be taken\n\nMust be a relative path from project  root"
        },
        "foldersFromRepo": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "if given, it will fetch these folders from the repo and paste them in the bundle whenever the bundle is generated\n\ncan be handy if you're working with someone else..."
        }
      },
      "required": [
        "bundles",
        "dependencies"
      ],
      "additionalProperties": false
    },
    "CustomisableBundleConfig": {
      "type": "object",
      "properties": {
        "isOffline": {
          "type": "boolean",
          "description": "if true, will not clone/pull/push and deploy. No internet is needed, will also not use any `.git` folder."
        },
        "skipPull": {
          "type": "boolean",
          "description": "skips the step where it gets the new stuff from github"
        },
        "skipPush": {
          "type": "boolean",
          "description": "skips the step where it pushes the new bundle to remote"
        },
        "skipUpsert": {
          "type": "boolean",
          "description": "skips the step where it saves to the db"
        },
        "debug": {
          "type": "boolean"
        },
        "description": {
          "type": "string",
          "description": "descriptioin for git commit, if pushing. Default is \"monorepo update\""
        },
        "branchName": {
          "type": "string",
          "description": "optionally, specify a custom branch name to pull from / push to / checkout (default is \"main\")"
        },
        "publicEnvironmentVariables": {
          "$ref": "#/definitions/EnvironmentVariableObject"
        },
        "privateEnvironmentVariables": {
          "$ref": "#/definitions/EnvironmentVariableObject",
          "description": "NB: should not end up in public repos!"
        },
        "gitUserEmail": {
          "type": "string",
          "description": "Configuration for your commit (needed for vercel deployment)"
        },
        "gitUserName": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "description": "configuration that can be applied when generating a new bundle\n\nIt can be put in the BundleConfig, but it can also be set manually for an individual Bundle Generation."
    },
    "EnvironmentVariableObject": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Json"
      }
    },
    "FinalBundleConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "customisableBundleConfig": {
          "$ref": "#/definitions/FinalCustomisableBundleConfig"
        },
        "createBundleConfig": {
          "$ref": "#/definitions/FinalCreateBundleConfig"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "slug": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "$ref": "#/definitions/Id"
        },
        "language": {
          "$ref": "#/definitions/Id"
        },
        "description": {
          "$ref": "#/definitions/Id"
        },
        "emoji": {
          "$ref": "#/definitions/Id"
        },
        "primaryColor": {
          "$ref": "#/definitions/Id"
        },
        "gitRepoUrl": {
          "$ref": "#/definitions/Id"
        },
        "isGitRepoPublic": {
          "$ref": "#/definitions/Id"
        },
        "bundleMarkdownReaderConfig": {
          "$ref": "#/definitions/Id"
        }
      },
      "required": [
        "createBundleConfig",
        "createdAt",
        "createdFirstAt",
        "customisableBundleConfig",
        "deletedAt",
        "id",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ]
    },
    "FinalCreateBundleConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "informationStrategy": {
          "$ref": "#/definitions/InformationStrategy",
          "description": "Default information strategy"
        },
        "foldersFromRepo": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "if given, it will fetch these folders from the repo and paste them in the bundle whenever the bundle is generated\n\ncan be handy if you're working with someone else..."
        },
        "keepStructure": {
          "type": "boolean",
          "description": "If true, the structure of operation locations is kept the same but still inside packages/apps/modules."
        },
        "modelInformationStrategy": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/InformationStrategy"
          },
          "description": "Information strategy per model\n\nFor example, this would ensure your diaries are not copied over to the bundle:\n\n```json { \"Diary\": \"ignore\" } ```\n\nIf you want to be certain something isn't included, instead of putting it into the model specific information strategy, you can also just put it in an operation that isn't required in the bundle.\n\nThis parameter is especially useful if you want to change a information stategy for one model in specific."
        },
        "additional_datasetSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be added or overwriting the data"
        },
        "filter_datasetSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "After applying the `informationStrategy`, and `modelInformationStrategy`, these datasets will be found in the then available data in the bundle, and will be filtered out."
        },
        "isDraft": {
          "type": "boolean",
          "description": "If true, this bundleconfig will be skipped when using `generateAllBundles`"
        },
        "keepTodos": {
          "type": "boolean",
          "description": "if true, todos are also copied into their original location, which is in `packages` if it's not in an operation, or in the operation in any of the folders if it's an operation.\n\nThe markdown-reader will then add them to a todo menu.\n\nNB: Only works in conjunction with `keepStructure`"
        },
        "bundles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FrontBackBundle"
          }
        },
        "dependencies": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationPrivacy"
          },
          "description": "Generated, private by default. If they're already here, uses private/public setting as given.\n\nWhen generating, removes the ones that are not dependencies (of dependencies) of your standalone apps"
        },
        "docsRelativeFolderPath": {
          "anyOf": [
            {
              "$ref": "#/definitions/ProjectRelativeFolderPath"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ProjectRelativeFolderPath"
              }
            }
          ],
          "description": "optional. Could also find the main file from here and use that as README.md\n\nMust be a relative path from project root. Can be multiple!"
        },
        "readmeRelativeFilePath": {
          "$ref": "#/definitions/ProjectRelativeFilePath",
          "description": "Optional. path to a readme file for the monorepo root.\n\nIf not given, and if you did provide a path for docs, the main docs intro file will be taken\n\nMust be a relative path from project  root"
        }
      },
      "required": [
        "bundles",
        "dependencies"
      ],
      "description": "CreateBundleConfig after applying the defaults"
    },
    "FinalCustomisableBundleConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "description": {
          "type": "string",
          "description": "descriptioin for git commit, if pushing. Default is \"monorepo update\""
        },
        "debug": {
          "type": "boolean"
        },
        "branchName": {
          "type": "string",
          "description": "optionally, specify a custom branch name to pull from / push to / checkout (default is \"main\")"
        },
        "isOffline": {
          "type": "boolean",
          "description": "if true, will not clone/pull/push and deploy. No internet is needed, will also not use any `.git` folder."
        },
        "skipPull": {
          "type": "boolean",
          "description": "skips the step where it gets the new stuff from github"
        },
        "skipPush": {
          "type": "boolean",
          "description": "skips the step where it pushes the new bundle to remote"
        },
        "skipUpsert": {
          "type": "boolean",
          "description": "skips the step where it saves to the db"
        },
        "publicEnvironmentVariables": {
          "$ref": "#/definitions/EnvironmentVariableObject"
        },
        "privateEnvironmentVariables": {
          "$ref": "#/definitions/EnvironmentVariableObject",
          "description": "NB: should not end up in public repos!"
        },
        "gitUserEmail": {
          "type": "string",
          "description": "Configuration for your commit (needed for vercel deployment)"
        },
        "gitUserName": {
          "type": "string"
        }
      }
    },
    "FrontBackBundle": {
      "type": "object",
      "properties": {
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationPrivacy"
          },
          "description": "any operation names that are not necesarily dependencies of the named front-back bundle but still need to be available."
        },
        "uiOperationName": {
          "type": "string",
          "description": "(optional) main shared ui package of the frontend"
        },
        "appShellOperationNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "which app shell(s) or app operations are there for the frontend?"
        },
        "serverOperationName": {
          "type": "string",
          "description": "operation name for server, if this UI is connected to one"
        },
        "productionWebUrl": {
          "type": "string",
          "description": "if there is a ui and it has a web-shell, and it is deployed somewhere into production, add the deployed domain here."
        },
        "productionApiUrl": {
          "type": "string",
          "description": "if there is one, it should be specified here (without trailing slash)"
        },
        "endpointsAuthToken": {
          "type": "string",
          "description": "if this is provided, all endpoints require this auth token to be provided, or the endpoints do not work\n\nif you wish to have a more extensive authentication method for your endpoints, make sure to create your own auth layer"
        }
      },
      "additionalProperties": false,
      "description": "This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately"
    },
    "InformationStrategy": {
      "type": "string",
      "enum": [
        "ignore",
        "push",
        "pullReplace",
        "pullMerge"
      ],
      "description": "push (default): take needed information from project and push to bundle (removing the existing info)\n\npullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n\npullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n\nignore: don't put any data in the bundle!"
    },
    "Json": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        },
        {
          "type": "boolean"
        },
        {
          "type": "null"
        },
        {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Json"
          }
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Json"
          }
        }
      ]
    },
    "OperationName": {
      "type": "string",
      "description": "later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n\nif it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n\nbesides simply having OperationName, we can have specific operation classification operation names:\n\n- JsOperationName (js)\n- NodeOperationName (node)\n- ServerOperationName (server)\n- AppShellOperationName (web, app, etc.)\n- UiOperationName (ui-es6 and ui-es5)"
    },
    "OperationPrivacy": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "privacy": {
          "type": "string",
          "enum": [
            "public",
            "private"
          ],
          "description": "if public, everything will be kept\n\nif private, src and todo will be removed from bundle, unless it's a ui-es6 operation, because src is needed then. In that case, only \"todo\" will be deleted."
        }
      },
      "required": [
        "operationName",
        "privacy"
      ],
      "additionalProperties": false
    },
    "ProjectRelativeFilePath": {
      "type": "string"
    },
    "ProjectRelativeFolderPath": {
      "type": "string",
      "description": "later this could be known by the frontend so it will render a ui to select a folder\n\nWe need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way."
    },
    "PublicBundleConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Human readable name of the monorepo (A kebab-case version of this will be used as root foldername)"
        },
        "description": {
          "type": "string",
          "description": "a description about this bundle"
        },
        "emoji": {
          "type": "string"
        },
        "primaryColor": {
          "type": "string"
        },
        "gitRepoUrl": {
          "type": "string",
          "description": "NB: later we may also want to automate the server and frontend deployment setup. for that we need credentials and automation"
        },
        "isGitRepoPublic": {
          "type": "boolean",
          "description": "if true, your gitrepo is marked as pubilc and thus users will be linked to it sometimes"
        },
        "bundleMarkdownReaderConfig": {
          "$ref": "#/definitions/BundleMarkdownReaderConfig",
          "description": "configurate your markdown reader"
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    },
    "ServerOperationName": {
      "type": "string"
    },
    "Slug": {
      "type": "string",
      "description": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example."
    },
    "SlugModelType": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "description": "use this model for things with a name that have an unique slug that can be used to identify the model"
    },
    "BundleSummary": {
      "type": "object",
      "properties": {
        "packageNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Haven't found a good usecase for this yet"
        },
        "moduleNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "appNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "packageNames",
        "moduleNames",
        "appNames"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getBundleSummary%3E": {
      "type": "object",
      "properties": {
        "bundleConfig": {
          "$ref": "#/definitions/BundleConfig"
        }
      },
      "required": [
        "bundleConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbModelsForBundle%3E": {
      "type": "object",
      "properties": {
        "bundleConfig": {
          "$ref": "#/definitions/BundleConfig"
        }
      },
      "required": [
        "bundleConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof cleanupTsDatabase%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof shouldDeleteTsModel%3E": {
      "type": "object",
      "properties": {
        "tsModel": {
          "anyOf": [
            {
              "$ref": "#/definitions/TsFunction"
            },
            {
              "$ref": "#/definitions/TsComment"
            },
            {
              "$ref": "#/definitions/TsInterface"
            },
            {
              "$ref": "#/definitions/TsBuildError"
            },
            {
              "$ref": "#/definitions/TsLintWarning"
            },
            {
              "$ref": "#/definitions/TsExport"
            },
            {
              "$ref": "#/definitions/TsImport"
            },
            {
              "$ref": "#/definitions/TsVariable"
            }
          ]
        },
        "operationName": {
          "type": "string"
        },
        "operationRelativePaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "tsModel",
        "operationName",
        "operationRelativePaths"
      ],
      "additionalProperties": false
    },
    "TsBuildError": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "line": {
          "type": "number"
        },
        "character": {
          "type": "number"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "message",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false
    },
    "TsComment": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "comment": {
          "$ref": "#/definitions/Markdown",
          "description": "the content of the comment in markdown, without frontmatter"
        },
        "parameters": {
          "$ref": "#/definitions/Frontmatter",
          "description": "parameters destructured from the frontmatter of the parsed markdown (if comment is not a oneliner, otherwise it'll be empty)"
        },
        "types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          },
          "description": "These are the type indicators that were found in this single or multiline comment. Can be multiple."
        },
        "firstLine": {
          "type": "number",
          "description": "first line of the comment"
        },
        "lastLine": {
          "type": "number",
          "description": "last line of the comment"
        },
        "statementName": {
          "type": "string",
          "description": "statement name the comment belongs to"
        },
        "rawStatement": {
          "type": "string",
          "description": "raw statement text the comment belongs to"
        }
      },
      "required": [
        "comment",
        "firstLine",
        "id",
        "lastLine",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "parameters",
        "projectRelativePath",
        "slug",
        "types"
      ],
      "additionalProperties": false,
      "description": "comments are basically one-or-multi-line human content inside of typescript files, so it's a very important to do something useful with them.\n\n\nThe convention should be that single-line comments should start with that. This then becomes the type of the comment. You can also put multiple prefixes at the start.\n\nExample:\n\n`// TODO: NB: this is a todo but its also important`\n\nMultiline comments can also have one or multiple types in their text, but they should not be split into multiple comments as the context could be needed some times.\n\n\n\nThere are also some other things comments can say about statements, but these should be inside the frontmatter, and are much more flexible.\n- classified[0-10] indicating level of classification. This way I can share subsets of the codebase, maybe...\n- privacy\n- ...?\n\nNB: with the current setup we can also parse `.md` files as being a TsComment, keep it that way!\n\nNB: comments are part of the code, so they should always be in English!"
    },
    "TsExport": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "comments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Creation%3CTsComment%3E"
          },
          "description": "surrounding comments and comments inside of the import"
        },
        "type": {
          "type": "string",
          "enum": [
            "value",
            "type"
          ]
        },
        "alias": {
          "type": "string",
          "description": "used for duplicate export names"
        },
        "hasGeneric": {
          "type": "boolean",
          "description": "only for type exports. tells you whether or not the type has one or more generic parameter(s)"
        }
      },
      "required": [
        "comments",
        "id",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false
    },
    "TsImport": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "comments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          },
          "description": "surrounding comments and comments inside of the import"
        },
        "module": {
          "type": "string"
        },
        "alias": {
          "type": "string",
          "description": "TODO: not sure, but I believe alias should be defined at the import, not at the export, right?"
        },
        "classification": {
          "$ref": "#/definitions/ImportClassification"
        },
        "type": {
          "type": "string",
          "enum": [
            "value",
            "type"
          ],
          "description": "sometimes the import statement module referenced cannot be found, in that case it cannot be known whether the import should contain a type or value, so it will be undefined."
        },
        "hasGeneric": {
          "type": "boolean",
          "description": "only for type exports. tells you whether or not the type has one or more generic parameter(s)"
        },
        "isAbsolute": {
          "type": "boolean"
        },
        "isModuleResolved": {
          "type": "boolean"
        },
        "isModuleFromMonorepo": {
          "type": "boolean"
        }
      },
      "required": [
        "classification",
        "comments",
        "id",
        "isAbsolute",
        "isModuleFromMonorepo",
        "isModuleResolved",
        "module",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false
    },
    "TsInterface": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "type": {
          "$ref": "#/definitions/TypeInfo"
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "jsdoc comment above the interface, if any"
        },
        "commentsInside": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          }
        },
        "isExported": {
          "type": "boolean",
          "description": "boolean indicating whether or not this interface is exported from the file, and with that, from the operation"
        },
        "hasGeneric": {
          "type": "boolean",
          "description": "boolean indicating whether or not this interface uses one or more generic variables"
        },
        "rawText": {
          "type": "string",
          "description": "raw interface text, coming from ts-morph"
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "if the interface extends anything, names will be specified here"
        },
        "isDbModel": {
          "type": "boolean",
          "description": "If true, this interface is marked as a db model, which means it will be included in the db function autocompletion so it's easy to store and fetch data in this format.\n\nIs automatically set to true when indexing and when one of the following statements holds true\n\n- if the doc-comment contains frontmatter with `isDbModel` or `dbStorageMethod` specified\n- if the interface last word is \"db\" or \"model\" and if there are minimum 2 words\n- if the interface extends some other special interface"
        },
        "isOperationIndex": {
          "type": "boolean",
          "description": "If this is true, this is a db-model that is ALWAYS attached to an operation.\n\nBy default this means it will get a folder in the `db` folder in the operation folder, where the interface will be stored linked to the file-id in specified folder.\n\nHowever, you can also specify a `storageLocationRelativeFilePath` if you want to store the model on an exact location relative to the operation root."
        },
        "operationStorageLocationRelativeFilePath": {
          "type": "string",
          "description": "If given, specify a file path here where the data should be stored. Must be an operation relative path.\n\nThis will map onto the \"operationRelativePath\" for that instance.\n\nNB: Since this is a single file per project or per operation, it will overwrite your data in case of `jsonSingle` or `markdown` storage."
        },
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod",
          "description": "The DbStorageMethod for this inteface (only for db models, otherwise this will be undefined)\n\nIf this interface is a db model, you can also specify the default db storage method for it. You can do this by specifying it in the frontmatter of the doccomment of the interface. You can also extend a xxxModelType model which can have a dbStorageMethod attached.\n\nWhen storing something into the database, this value can be overwritten in your query configuration."
        }
      },
      "required": [
        "commentsInside",
        "hasGeneric",
        "id",
        "isDbModel",
        "isExported",
        "isOperationIndex",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug",
        "type"
      ],
      "additionalProperties": false,
      "description": "--- dbStorageMethod: jsonSingle\n---\n\nTODO: Just like parameters, this should be linted for. If you define an interface that's not declared here, that should ring a bell."
    },
    "TsLintWarning": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "line": {
          "type": "number"
        },
        "character": {
          "type": "number"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "character",
        "id",
        "line",
        "message",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false
    },
    "TsVariable": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "description": {
          "type": "string",
          "description": "if available , the parsed doccomment of the variable"
        },
        "value": {
          "type": "string"
        },
        "classification": {
          "type": "string",
          "enum": [
            "const",
            "var",
            "let"
          ]
        },
        "type": {
          "$ref": "#/definitions/TypeInfo"
        },
        "isExported": {
          "type": "boolean"
        },
        "comments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Creation%3CTsComment%3E"
          },
          "description": "surrounding comments and comments inside of the variable"
        }
      },
      "required": [
        "classification",
        "comments",
        "id",
        "isExported",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug",
        "type",
        "value"
      ],
      "additionalProperties": false,
      "description": "--- dbStorageMethod: jsonSingle\n---"
    },
    "AnyModelType": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        }
      },
      "required": [
        "id",
        "operationName",
        "projectRelativePath"
      ],
      "additionalProperties": false,
      "description": "Parameters that every model will always have.\n\nNB: TimeTypes (createdAt, updatedAt, etc.) are not always included because the kvmd-model doesn't have them.\n\nNB: RelationTypes are also not always included for the same reason"
    },
    "CategorizedFilePaths": {
      "type": "object",
      "properties": {
        "code": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "data": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "text": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "code",
        "data",
        "text"
      ],
      "additionalProperties": false,
      "description": "filepaths categorized based on the filetype. With king os there are only these filetypes:\n\n- code: ts, tsx\n- data: json\n- text: md, mdx"
    },
    "CategoryStack": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "CommentType": {
      "type": "string",
      "enum": [
        "todo",
        "discussion",
        "idea",
        "later",
        "nb",
        "title",
        "section",
        "description"
      ],
      "description": "special line prefixes:\n\n**Developer related comments**\n\n- TODO: for developer to know what to do\n- DISCUSSION: for developer to state that discussion is needed\n- IDEA: for developer to state ideas\n- LATER: for developer to mark as thing that needs to be done later\n- NB: for developer to add a note\n\n**Form related comments**\n\n- TITLE: if available, will be used as title of form input (overwrites humanCase version of the property-name itself in that case)\n- SECTION: start a new section in the form from this point, the value behind here can be the title\n- DESCRIPTION: if available, will be used as description of the form input"
    },
    "CommentTypeObject": {
      "type": "object",
      "properties": {
        "todo": {
          "type": "string"
        },
        "discussion": {
          "type": "string"
        },
        "idea": {
          "type": "string"
        },
        "later": {
          "type": "string"
        },
        "nb": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "section": {
          "type": "string"
        },
        "description": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "description": "Every `CommentType` can be a key in the `SimplifiedSchema`, if available."
    },
    "CompilerOptions": {
      "type": "object",
      "properties": {
        "allowJs": {
          "type": "boolean"
        },
        "allowSyntheticDefaultImports": {
          "type": "boolean"
        },
        "allowUmdGlobalAccess": {
          "type": "boolean"
        },
        "allowUnreachableCode": {
          "type": "boolean"
        },
        "allowUnusedLabels": {
          "type": "boolean"
        },
        "alwaysStrict": {
          "type": "boolean"
        },
        "baseUrl": {
          "type": "string"
        },
        "charset": {
          "type": "string"
        },
        "checkJs": {
          "type": "boolean"
        },
        "declaration": {
          "type": "boolean"
        },
        "declarationMap": {
          "type": "boolean"
        },
        "emitDeclarationOnly": {
          "type": "boolean"
        },
        "declarationDir": {
          "type": "string"
        },
        "disableSizeLimit": {
          "type": "boolean"
        },
        "disableSourceOfProjectReferenceRedirect": {
          "type": "boolean"
        },
        "disableSolutionSearching": {
          "type": "boolean"
        },
        "disableReferencedProjectLoad": {
          "type": "boolean"
        },
        "downlevelIteration": {
          "type": "boolean"
        },
        "emitBOM": {
          "type": "boolean"
        },
        "emitDecoratorMetadata": {
          "type": "boolean"
        },
        "exactOptionalPropertyTypes": {
          "type": "boolean"
        },
        "experimentalDecorators": {
          "type": "boolean"
        },
        "forceConsistentCasingInFileNames": {
          "type": "boolean"
        },
        "importHelpers": {
          "type": "boolean"
        },
        "importsNotUsedAsValues": {
          "$ref": "#/definitions/ImportsNotUsedAsValues"
        },
        "inlineSourceMap": {
          "type": "boolean"
        },
        "inlineSources": {
          "type": "boolean"
        },
        "isolatedModules": {
          "type": "boolean"
        },
        "jsx": {
          "$ref": "#/definitions/JsxEmit"
        },
        "keyofStringsOnly": {
          "type": "boolean"
        },
        "lib": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "locale": {
          "type": "string"
        },
        "mapRoot": {
          "type": "string"
        },
        "maxNodeModuleJsDepth": {
          "type": "number"
        },
        "module": {
          "$ref": "#/definitions/ModuleKind"
        },
        "moduleResolution": {
          "$ref": "#/definitions/ModuleResolutionKind"
        },
        "moduleSuffixes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "moduleDetection": {
          "$ref": "#/definitions/ModuleDetectionKind"
        },
        "newLine": {
          "$ref": "#/definitions/NewLineKind"
        },
        "noEmit": {
          "type": "boolean"
        },
        "noEmitHelpers": {
          "type": "boolean"
        },
        "noEmitOnError": {
          "type": "boolean"
        },
        "noErrorTruncation": {
          "type": "boolean"
        },
        "noFallthroughCasesInSwitch": {
          "type": "boolean"
        },
        "noImplicitAny": {
          "type": "boolean"
        },
        "noImplicitReturns": {
          "type": "boolean"
        },
        "noImplicitThis": {
          "type": "boolean"
        },
        "noStrictGenericChecks": {
          "type": "boolean"
        },
        "noUnusedLocals": {
          "type": "boolean"
        },
        "noUnusedParameters": {
          "type": "boolean"
        },
        "noImplicitUseStrict": {
          "type": "boolean"
        },
        "noPropertyAccessFromIndexSignature": {
          "type": "boolean"
        },
        "assumeChangesOnlyAffectDirectDependencies": {
          "type": "boolean"
        },
        "noLib": {
          "type": "boolean"
        },
        "noResolve": {
          "type": "boolean"
        },
        "noUncheckedIndexedAccess": {
          "type": "boolean"
        },
        "out": {
          "type": "string"
        },
        "outDir": {
          "type": "string"
        },
        "outFile": {
          "type": "string"
        },
        "paths": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": "Type of objects whose values are all of the same type. The `in` and `for-in` operators can *not* be safely used, since `Object.prototype` may be modified by outside code."
        },
        "preserveConstEnums": {
          "type": "boolean"
        },
        "noImplicitOverride": {
          "type": "boolean"
        },
        "preserveSymlinks": {
          "type": "boolean"
        },
        "preserveValueImports": {
          "type": "boolean"
        },
        "project": {
          "type": "string"
        },
        "reactNamespace": {
          "type": "string"
        },
        "jsxFactory": {
          "type": "string"
        },
        "jsxFragmentFactory": {
          "type": "string"
        },
        "jsxImportSource": {
          "type": "string"
        },
        "composite": {
          "type": "boolean"
        },
        "incremental": {
          "type": "boolean"
        },
        "tsBuildInfoFile": {
          "type": "string"
        },
        "removeComments": {
          "type": "boolean"
        },
        "rootDir": {
          "type": "string"
        },
        "rootDirs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "skipLibCheck": {
          "type": "boolean"
        },
        "skipDefaultLibCheck": {
          "type": "boolean"
        },
        "sourceMap": {
          "type": "boolean"
        },
        "sourceRoot": {
          "type": "string"
        },
        "strict": {
          "type": "boolean"
        },
        "strictFunctionTypes": {
          "type": "boolean"
        },
        "strictBindCallApply": {
          "type": "boolean"
        },
        "strictNullChecks": {
          "type": "boolean"
        },
        "strictPropertyInitialization": {
          "type": "boolean"
        },
        "stripInternal": {
          "type": "boolean"
        },
        "suppressExcessPropertyErrors": {
          "type": "boolean"
        },
        "suppressImplicitAnyIndexErrors": {
          "type": "boolean"
        },
        "target": {
          "$ref": "#/definitions/ScriptTarget"
        },
        "traceResolution": {
          "type": "boolean"
        },
        "useUnknownInCatchVariables": {
          "type": "boolean"
        },
        "resolveJsonModule": {
          "type": "boolean"
        },
        "types": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "typeRoots": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Paths used to compute primary types search locations"
        },
        "esModuleInterop": {
          "type": "boolean"
        },
        "useDefineForClassFields": {
          "type": "boolean"
        }
      },
      "additionalProperties": {
        "anyOf": [
          {},
          {
            "not": {}
          }
        ]
      }
    },
    "Dataset": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "modelName": {
          "type": "string",
          "description": "The model you want to make a dataset from"
        },
        "filter": {
          "anyOf": [
            {
              "$ref": "#/definitions/DatasetFilter"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/DatasetFilter"
              }
            }
          ],
          "description": "Filters are applied after each other"
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/DatasetSort"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/DatasetSort"
              }
            }
          ]
        },
        "maxRows": {
          "type": "number",
          "description": "Specify a max amount of items n"
        },
        "startFromIndex": {
          "type": "number",
          "description": "If specified, slices the sorted array to omit the first n items;"
        },
        "objectParameterKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "If specified, will only include these parameter keys of the model object. Otherwise all keys will be taken"
        },
        "ignoreObjectParameterKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "If specified, will omit these keys when creating the dataset"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "modelName",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "DatasetFilter": {
      "type": "object",
      "properties": {
        "objectParameterKey": {
          "type": "string"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "equal",
            "notEqual",
            "gt",
            "gte",
            "lt",
            "lte"
          ],
          "description": "Uses type equality"
        },
        "filterFunctionName": {
          "type": "string",
          "description": "TODO: Maybe add possibility to use a sort function from the SDK"
        }
      },
      "required": [
        "objectParameterKey",
        "operator"
      ],
      "additionalProperties": false,
      "description": "Can be better, see https://www.w3schools.com/js/js_comparisons.asp"
    },
    "DatasetSort": {
      "type": "object",
      "properties": {
        "objectParameterKey": {
          "type": "string"
        },
        "sortDirection": {
          "type": "string",
          "enum": [
            "ascending",
            "descending"
          ],
          "description": "sort normally or in reverse order"
        },
        "sortFunctionName": {
          "type": "string",
          "description": "TODO:"
        }
      },
      "required": [
        "objectParameterKey"
      ],
      "additionalProperties": false,
      "description": "Sort by comparing the two values using the `Array.sort` method and Greater than and Less than operators."
    },
    "DbStorageMethod": {
      "type": "string",
      "enum": [
        "jsonMultiple",
        "jsonSingle",
        "markdown",
        "keyValueMarkdown",
        "csv"
      ],
      "description": "The following strategies are available to store the data.\n\n- **jsonMultiple *(default)***: stores the data in a json file which is an array of this data structure. This file will be located in `db/[pluralized-kebab-case-model-name].json`\n\n- **jsonSingle**: stores the data in a json file which is of this data structure (single object) These files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].json`\n\n- **markdown**: stores the data in a markdown file. Takes \"markdown\" parameter as the main markdown. The other parameters are stored as front-matter. This these files will be located in `db/[pluralized-kebab-case-model-name]/[instance-slug-or-id].md`\n\n- **keyValueMarkdown**: stores the data in key value markdown format. This file will be located in `db/[pluralized-kebab-case-model-name].md`\n\n- **csv**: stores the data in a csv file (only possible for flat object datastructures). This file will be located in `db/[pluralized-kebab-case-model-name].csv`\n\n## Definitions:\n\n- [pluralized-kebab-case-model-name]: e.g. `StudentUser` becomes `student-users`\n- [instance-slug-or-id]: For all models with a slug parameter, the filename will be that slug of that instance. Otherwise, `id` will be used"
    },
    "Downmatter": {
      "type": "object",
      "properties": {
        "detectedLanguage": {
          "type": "string"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "ExplorationDetails": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "tsBuildErrors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsBuildError"
          }
        },
        "tsLintWarnings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsLintWarning"
          }
        },
        "tsFunctions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "tsVariables": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsVariable"
          }
        },
        "tsInterfaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsInterface"
          }
        },
        "tsComments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          }
        },
        "tsImports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsImport"
          }
        },
        "tsExports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsExport"
          }
        },
        "success": {
          "type": "boolean"
        },
        "response": {
          "type": "string"
        },
        "markdown": {
          "$ref": "#/definitions/MarkdownParse"
        },
        "pathMetaData": {
          "$ref": "#/definitions/PathMetaData"
        },
        "operationIndexes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationIndex"
          }
        },
        "index": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsInterface"
          }
        }
      },
      "required": [
        "index"
      ]
    },
    "FolderExploration": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "folder",
            "operation",
            "operationFolder",
            "markdown",
            "typescript",
            "function",
            "interface",
            "variable"
          ],
          "description": "folder is a regular folder outside of operations\n\noperation is a folder that is the root of an operation\n\noperationFolder is a folder inside of an operation\n\nother things are self-explanatory"
        },
        "name": {
          "type": "string"
        },
        "relativeProjectPath": {
          "type": "string",
          "description": "path to the folder, operation, operationFolder, or file. functions, interfaces or variables direct to the file they are defined in"
        },
        "children": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FolderExploration"
          },
          "description": "Every FolderExploration has children, which are simply the files/folders that can be found in there. The children of files are functions, interfaces and variables for typescript files. Markdownfiles don't get any children (although we could childify the outline of the file, maybe, later...)"
        }
      },
      "required": [
        "type",
        "name",
        "relativeProjectPath"
      ],
      "additionalProperties": false,
      "description": "suggested type for menu is FolderExploration[]\n\nNB: recursive!"
    },
    "FolderSummary": {
      "type": "object",
      "properties": {
        "size": {
          "$ref": "#/definitions/SizeSummary"
        },
        "textSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "dataSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "codeSize": {
          "$ref": "#/definitions/SizeSummary"
        }
      },
      "required": [
        "size",
        "textSize",
        "dataSize",
        "codeSize"
      ],
      "additionalProperties": false,
      "description": "objective size measurements of all files in a folder\n\nsummary for a folder should contain file-summaries for different filetypes and an overal file summary"
    },
    "Frontmatter": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "null"
          },
          {
            "type": "boolean"
          },
          {
            "not": {}
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "description": "Our version of frontmatter is a bit simpler than regular frontmatter\n\nNot sure if this is a good idea, but it keeps it simple for our OS\n\nall values parse in a similar way to csv\n\nmake sure that you use quotes if you want to store a string with commas, because commas in a parameter indicate that it is a string array\n\nNB: string arrays are comma separated values, where you can put values with special characters in between quotes"
    },
    "FunctionExecution": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "functionName": {
          "type": "string"
        },
        "tsFunctionId": {
          "$ref": "#/definitions/Id"
        },
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        },
        "inputParameters": {
          "type": "array",
          "items": {}
        },
        "output": {},
        "isTest": {
          "type": "boolean"
        },
        "isExample": {
          "type": "boolean"
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "test description or example description or anything"
        },
        "isResultFromCache": {
          "type": "boolean"
        },
        "hasApiChanged": {
          "type": "boolean",
          "description": "if true, the api of the function (input/output interface) has changed in bewteen, so the re-execution would probably fail or return a different result"
        },
        "performance": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerformanceItem"
          }
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "description",
        "functionName",
        "id",
        "isExample",
        "isResultFromCache",
        "isTest",
        "operationName",
        "output",
        "performance",
        "projectRelativePath",
        "tsFunctionId",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Model for tests, examples, cache, and recent executions of any function\n\nRequirement for **tifo-stitching**\n\nExample: \n\nconst someFunction = (inputA: string, inputB:string):string => {\n\nreturn `${inputA} != ${inputB}` }\n\n\n// find this in the database after executing the function\n\nconst functionExecution1 = { .... functionName: \"someFunction\", inputParameters: [\"hello\", \"world\"], output: \"hello != world\", isTest: false, isExample: false, isResultFromCache: false, performance: [....], }"
    },
    "GeneralOperationIndex": {
      "type": "object",
      "properties": {
        "updatedAt": {
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "packageName": {
          "type": "string",
          "description": "name of the package in package.json"
        },
        "folderName": {
          "type": "string",
          "description": "name of the operation folder"
        },
        "relativeOperationLocationPath": {
          "type": "string",
          "description": "relative path to the operation (does not include operation folder itself)\n\nrelative from project root"
        },
        "classification": {
          "$ref": "#/definitions/OperationClassification"
        },
        "packageDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "package dependency names (non-operation)"
        },
        "operationDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "operation dependency names"
        },
        "coreDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "core dependencies (e.g. `path` and `fs`)"
        }
      },
      "required": [
        "updatedAt",
        "name",
        "slug",
        "packageName",
        "folderName",
        "relativeOperationLocationPath",
        "classification",
        "packageDependencies",
        "operationDependencies",
        "coreDependencies"
      ],
      "additionalProperties": false
    },
    "Id": {
      "type": "string",
      "description": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this."
    },
    "ImportClassification": {
      "type": "string",
      "enum": [
        "node",
        "react",
        "package",
        "operation",
        "internal"
      ],
      "description": "node: node core packages like fs and path\n\nreact: react standard packages like react, react-native, expo, react-dom, etc.\n\npackage: packages from npm that are not classified as operations\n\noperation: operations from our monorepo\n\ninternal: imports from other places in the same operation\n\nNB: don't confuse this with OperationClassification"
    },
    "IndexModels": {
      "type": "object",
      "properties": {
        "TsBuildError": {
          "$ref": "#/definitions/TsBuildError"
        },
        "TsLintWarning": {
          "$ref": "#/definitions/TsLintWarning"
        },
        "TsFunction": {
          "$ref": "#/definitions/TsFunction"
        },
        "TsVariable": {
          "$ref": "#/definitions/TsVariable"
        },
        "TsInterface": {
          "$ref": "#/definitions/TsInterface"
        },
        "TsComment": {
          "$ref": "#/definitions/TsComment"
        },
        "TsImport": {
          "$ref": "#/definitions/TsImport"
        },
        "TsExport": {
          "$ref": "#/definitions/TsExport"
        }
      },
      "required": [
        "TsBuildError",
        "TsLintWarning",
        "TsFunction",
        "TsVariable",
        "TsInterface",
        "TsComment",
        "TsImport",
        "TsExport"
      ],
      "additionalProperties": false
    },
    "JSONSchema7Type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        },
        {
          "type": "boolean"
        },
        {
          "$ref": "#/definitions/JSONSchema7Object"
        },
        {
          "$ref": "#/definitions/JSONSchema7Array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Primitive type"
    },
    "Language": {
      "type": "string",
      "enum": [
        "english",
        "dutch",
        "nepali",
        "portuguese",
        "brazilian",
        "german",
        "french",
        "spanish",
        "italian",
        "norwegian",
        "swedish",
        "danish",
        "vietnamese",
        "indonesian",
        "southAfrican",
        "tokiPona",
        "hindi",
        "mandarin",
        "arabic",
        "bengali",
        "urdu",
        "japanese",
        "swahili"
      ],
      "description": "all currently supported languages"
    },
    "Markdown": {
      "type": "string",
      "description": "a string that is known to contain markdown."
    },
    "MarkdownAssetType": {
      "type": "string",
      "enum": [
        "youtube",
        "video",
        "image",
        "audio",
        "markdown",
        "json",
        "typescript",
        "file"
      ],
      "description": "type of asset that is being embedded"
    },
    "MarkdownChunk": {
      "type": "object",
      "properties": {
        "level": {
          "$ref": "#/definitions/MarkdownContentLevel"
        },
        "content": {
          "type": "string"
        },
        "markdownEmbed": {
          "$ref": "#/definitions/MarkdownEmbed"
        },
        "markdownLink": {
          "$ref": "#/definitions/MarkdownLink"
        },
        "title": {
          "type": "string",
          "description": "NB: title can also be an empty string (\"\")"
        },
        "children": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownChunk"
          },
          "description": "all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs"
        }
      },
      "required": [
        "level"
      ],
      "additionalProperties": false
    },
    "MarkdownContentLevel": {
      "type": "number",
      "description": "0 is a paragraph 1-6 is h1 until h6"
    },
    "MarkdownEmbed": {
      "type": "object",
      "properties": {
        "alt": {
          "type": "string"
        },
        "src": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/MarkdownAssetType"
        }
      },
      "required": [
        "alt",
        "src",
        "type"
      ],
      "additionalProperties": false,
      "description": "Anything in the format `![alt](src)`\n\nNB: I need to be very clear how this one works"
    },
    "MarkdownHeader": {
      "type": "object",
      "properties": {
        "level": {
          "$ref": "#/definitions/MarkdownContentLevel"
        },
        "title": {
          "type": "string"
        }
      },
      "required": [
        "level",
        "title"
      ],
      "additionalProperties": false
    },
    "MarkdownLink": {
      "type": "object",
      "properties": {
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/MarkdownAssetType",
          "description": "Can be inferred from href"
        }
      },
      "required": [
        "alt",
        "href",
        "type"
      ],
      "additionalProperties": false,
      "description": "Anything in the format `[alt](href)`\n\nIt needs to be clear how this works. There is a convention for this, and I should implement that as good as possible, and document it here"
    },
    "MarkdownModelType": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      },
      "description": "Handy model type for storing stuff in a Markdown file.\n\n1 markdown file will represent 1 MarkdownModelType extended instance\n\nanother option could be to parse the markdown file, but to KISS we are going to just return markdown with the full markdown content\n\nTODO: see how this relates to MarkdownFile. Make this very clear!"
    },
    "MarkdownParagraph": {
      "type": "object",
      "properties": {
        "paragraph": {
          "type": "string",
          "description": "the raw text of this paragraph"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "the parent stack"
        },
        "level": {
          "$ref": "#/definitions/MarkdownContentLevel",
          "description": "if the paragraph is NB: not always used!"
        }
      },
      "required": [
        "paragraph",
        "categoryStackCalculated"
      ],
      "additionalProperties": false
    },
    "MarkdownParse": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string",
          "description": "if available, this can be the filename of the markdown in this markdown-parse. Can be used for things like merging"
        },
        "createdAt": {
          "type": "number"
        },
        "openedAt": {
          "type": "number"
        },
        "updatedAt": {
          "type": "number"
        },
        "deletedAt": {
          "type": "number"
        },
        "createdFirstAt": {
          "type": "number"
        },
        "parameters": {
          "$ref": "#/definitions/Frontmatter",
          "description": "parameters found in frontmatter"
        },
        "downmatterParameters": {
          "$ref": "#/definitions/Downmatter",
          "description": "downmatter is the same as frontmatter, but it is to be found at the end of the file. It is supposed to be containing things that are not important for the user to know, yet it is important metadata that is connected to this file. This can be indexed things, for example."
        },
        "content": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownChunk"
          },
          "description": "structured content based on h1, h2, h3, etc (paragraphs, recursive)"
        },
        "raw": {
          "type": "string",
          "description": "raw markdown without frontmatter"
        }
      },
      "required": [
        "parameters",
        "raw"
      ],
      "additionalProperties": false
    },
    "MaybeInteface": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "$ref": "#/definitions/TypeInfo"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "jsdoc comment above the interface, if any"
        },
        "commentsInside": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          }
        },
        "isExported": {
          "type": "boolean",
          "description": "boolean indicating whether or not this interface is exported from the file, and with that, from the operation"
        },
        "hasGeneric": {
          "type": "boolean",
          "description": "boolean indicating whether or not this interface uses one or more generic variables"
        },
        "rawText": {
          "type": "string",
          "description": "raw interface text, coming from ts-morph"
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "if the interface extends anything, names will be specified here"
        },
        "isDbModel": {
          "type": "boolean",
          "description": "If true, this interface is marked as a db model, which means it will be included in the db function autocompletion so it's easy to store and fetch data in this format.\n\nIs automatically set to true when indexing and when one of the following statements holds true\n\n- if the doc-comment contains frontmatter with `isDbModel` or `dbStorageMethod` specified\n- if the interface last word is \"db\" or \"model\" and if there are minimum 2 words\n- if the interface extends some other special interface"
        },
        "isOperationIndex": {
          "type": "boolean",
          "description": "If this is true, this is a db-model that is ALWAYS attached to an operation.\n\nBy default this means it will get a folder in the `db` folder in the operation folder, where the interface will be stored linked to the file-id in specified folder.\n\nHowever, you can also specify a `storageLocationRelativeFilePath` if you want to store the model on an exact location relative to the operation root."
        },
        "operationStorageLocationRelativeFilePath": {
          "type": "string",
          "description": "If given, specify a file path here where the data should be stored. Must be an operation relative path.\n\nThis will map onto the \"operationRelativePath\" for that instance.\n\nNB: Since this is a single file per project or per operation, it will overwrite your data in case of `jsonSingle` or `markdown` storage."
        },
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod",
          "description": "The DbStorageMethod for this inteface (only for db models, otherwise this will be undefined)\n\nIf this interface is a db model, you can also specify the default db storage method for it. You can do this by specifying it in the frontmatter of the doccomment of the interface. You can also extend a xxxModelType model which can have a dbStorageMethod attached.\n\nWhen storing something into the database, this value can be overwritten in your query configuration."
        }
      },
      "required": [
        "commentsInside",
        "hasGeneric",
        "id",
        "isDbModel",
        "isExported",
        "isOperationIndex",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug",
        "type"
      ],
      "description": "at some point in processing we need this interface where definition can also be null"
    },
    "ModelInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "rows": {
          "type": "number"
        }
      },
      "required": [
        "name",
        "slug",
        "rows"
      ],
      "additionalProperties": false,
      "description": "used to show a list of models available in a menu structure"
    },
    "NamedParameters%3Ctypeof getExamples%3E": {
      "type": "object",
      "properties": {
        "functionName": {
          "type": "string"
        }
      },
      "required": [
        "functionName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFunctionExersize%3E": {
      "type": "object",
      "properties": {
        "functionId": {
          "type": "string"
        }
      },
      "required": [
        "functionId"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownParseToMarkdownModelType%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkdownParse"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "markdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseMarkdownModelTimestamp%3E": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/Frontmatter"
        },
        "markdownParse": {
          "$ref": "#/definitions/MarkdownParse"
        },
        "parameterName": {
          "type": "string",
          "enum": [
            "createdAt",
            "createdFirstAt",
            "updatedAt",
            "deletedAt",
            "openedAt"
          ]
        }
      },
      "required": [
        "parameters",
        "markdownParse",
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tryParseDate%3E": {
      "type": "object",
      "properties": {
        "dateString": {
          "type": "string"
        }
      },
      "required": [
        "dateString"
      ],
      "additionalProperties": false
    },
    "OperationClassification": {
      "type": "string",
      "enum": [
        "js",
        "ts",
        "node",
        "server",
        "web",
        "app",
        "ui-es6",
        "ui-es5",
        "ui-esm"
      ],
      "description": "# Classification\n\nTODO: think about what the differences are and how we need to change processes to make it all work good\n\n## Possible values\n\njs: only js (no node) (well, ts of course, but it gets built into js)\n\nts: non-built ts code\n\nnode: includes other node packages, operations, core-imports, or globals.\n\nserver: exposes something on some port when it is ran and uses node code\n\nweb: has next.config.js and thus exposes something on some port when it is ran. next.js + react-based...\n\napp: uses react-native and exposes something on some port when it is ran\n\nDEPRECATED: ui-es6: uses react (with (native)), which main entry points to typescript es6 files (this ui package cannot be built, should be transpiled. highly discouraged, please use ui-es5, or, if needed, ui-esm)\n\nui-es5: ui which main entry points to javascript es5 files (this ui package can be built)\n\nui-esm: ui which builds to ESM module resolved Javascript"
    },
    "OperationConfig": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "Any descriptions in markdown format\n\n- Markdown description of what the operation does.\n- Installation instructions, if it is possible\n- Usage instructions (with example), if available\n\nThis is the main content of the markdown file"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "indirectDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Sometimes you are using function in a UI, which cannot be inferred with imports because they are used indirectly via an api. Here you can specify which operations on the backend are needed for an operation (ui mostly)\n\nThis array is simply a list of operation names needed for this operation that are not imported.\n\nNB: no need to specify things here that you also import in this operation, because these are already automatically detected."
        },
        "authors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of authors\n\nShould be used to create bundle AUTHORS.md"
        },
        "contributors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of contributors\n\nCan be used to create bundle CONTRIBUTORS.md"
        },
        "shortDescriptionText": {
          "type": "string",
          "description": "one-line explanation of what the operation does (no markdown)"
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      },
      "description": "--- operationRelativePath: OPERATION.md isOperationIndex: true\n---\n\nanything configurable about the operation.\n\nOf course we could make this live in operation.json or as a prop in package.json, but it would be better to make it work with a markdown file.\n\nLet's try to use OPERATION.md\n\nTODO: Make this work and make sure the operationconfig is parsed from this file using `db.get(\"OperationConfig\")` as per convention."
    },
    "OperationIndex": {
      "type": "object",
      "properties": {
        "slug": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "type": "number"
        },
        "updatedAt": {
          "type": "number"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "here for compatibility, should implement..."
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "packageName": {
          "type": "string",
          "description": "name of the package in package.json"
        },
        "folderName": {
          "type": "string",
          "description": "name of the operation folder"
        },
        "relativeOperationLocationPath": {
          "type": "string",
          "description": "relative path to the operation (does not include operation folder itself)\n\nrelative from project root"
        },
        "classification": {
          "$ref": "#/definitions/OperationClassification"
        },
        "packageDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "package dependency names (non-operation)"
        },
        "operationDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "operation dependency names"
        },
        "coreDependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "core dependencies (e.g. `path` and `fs`)"
        },
        "buildSucceeded": {
          "type": "boolean"
        },
        "dependenciesBuildsFailed": {
          "type": "boolean"
        },
        "indexImportExportError": {
          "type": "string"
        },
        "lintProblems": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "indexInteracesErrors": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "indexErrors": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "size": {
          "$ref": "#/definitions/FolderSummary"
        }
      },
      "required": [
        "buildSucceeded",
        "classification",
        "coreDependencies",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "dependenciesBuildsFailed",
        "folderName",
        "id",
        "indexErrors",
        "indexImportExportError",
        "indexInteracesErrors",
        "language",
        "lintProblems",
        "name",
        "operationDependencies",
        "operationName",
        "packageDependencies",
        "packageName",
        "projectRelativePath",
        "relativeOperationLocationPath",
        "size",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "--- dbStorageMethod: jsonSingle operationRelativePath: db/operation-index.json\n---\n\ncontains all calculated info about an operation that needs to be retreived often: some package-only things, but also a collection of all indexes of all files\n\nshould be able to be found in operaiton folder in /db/operation-index.json"
    },
    "OperationPathParse": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "relativeOperationBasePathFromProjectRoot": {
          "type": "string",
          "description": "relative file path from the project-root to the operation (DOES include operation folder)\n\ne.g. /tools/cognition/typescript/index-typescript"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation src\n\ne.g. general.ts"
        },
        "srcFileId": {
          "type": "string",
          "description": "file id (same as operationRelativeTypescriptFilePath but without extension)\n\ne.g. \"general\"\n\nTODO: figure out if this can be omitted"
        },
        "operationName": {
          "type": "string",
          "description": "operation package.json name"
        },
        "operationFolderName": {
          "type": "string",
          "description": "operation folder name (by convention, must be identical to operationName, but it could have some mistakes)"
        },
        "relativePathFromProjectRoot": {
          "type": "string",
          "description": "relative file or folder path from the project root"
        }
      },
      "required": [
        "operationFolderName",
        "operationRelativeTypescriptFilePath",
        "relativeOperationBasePathFromProjectRoot",
        "relativePathFromProjectRoot",
        "srcFileId"
      ]
    },
    "PackageInfoObject": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "PackageJson": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "path": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "main": {
          "type": "string"
        },
        "source": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "private": {
          "type": "boolean"
        },
        "author": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          ]
        },
        "repository": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                },
                "directory": {
                  "type": "string"
                }
              },
              "required": [
                "url"
              ],
              "additionalProperties": false
            }
          ]
        },
        "homepage": {
          "type": "string"
        },
        "dependencies": {
          "$ref": "#/definitions/PackageInfoObject"
        },
        "devDependencies": {
          "$ref": "#/definitions/PackageInfoObject"
        },
        "peerDependencies": {
          "$ref": "#/definitions/PackageInfoObject"
        },
        "bin": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "workspaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scripts": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "type": {
          "$ref": "#/definitions/OperationClassification"
        },
        "sensible": {
          "$ref": "#/definitions/SensibleConfig"
        },
        "operation": {
          "$ref": "#/definitions/OperationConfig"
        }
      },
      "additionalProperties": false,
      "required": [
        "id",
        "operationName",
        "projectRelativePath"
      ],
      "description": "--- dbStorageMethod: jsonSingle operationRelativePath: package.json\n---"
    },
    "ParameterName": {
      "type": "object",
      "properties": {
        "pattern": {
          "type": "string"
        },
        "example": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/SimplifiedSchemaType"
        },
        "secondaryType": {
          "$ref": "#/definitions/SimplifiedSchemaType",
          "description": "in case of array, what's in the array?"
        },
        "contentType": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "generated",
              "markdown",
              "text",
              "number",
              "date",
              "time",
              "datetime",
              "toggle",
              "select",
              "selectMultiple"
            ]
          }
        }
      },
      "required": [
        "pattern",
        "example",
        "description",
        "type",
        "contentType"
      ],
      "additionalProperties": false
    },
    "PathMetaData": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "relativePathFromProjectRoot": {
          "type": "string",
          "description": "relative file or folder path from the project root"
        },
        "mainComment": {
          "$ref": "#/definitions/TsComment",
          "description": "a comment about this file or folder. Can be parsed from:\n- an associated markdown file and/or the top of the file (If they're both there, they're concatenated)\n- for folders, looks for README.md"
        },
        "fullFileName": {
          "type": "string",
          "description": "filename including extension, if the path is not a folder"
        },
        "isFolder": {
          "type": "boolean"
        },
        "updatedAt": {
          "type": "number",
          "description": "unix time this file was last updated (or for folders: unix time of last modifiation of any file in this folder, recursively)\n\nTODO: renames also count as updates, I guess. Needs to be clear!"
        },
        "createdAt": {
          "type": "number",
          "description": "unix time this file was created (or for folders: unix time of creation of the first file in this folder)\n\nTODO: figure out if we can get the creation date of the folder itself?"
        },
        "sizes": {
          "$ref": "#/definitions/FolderSummary",
          "description": "categorized sizes for the file(s)"
        }
      },
      "required": [
        "createdAt",
        "isFolder",
        "relativePathFromProjectRoot",
        "sizes",
        "updatedAt"
      ],
      "description": "All interesting metadata about any path (files and folders)"
    },
    "PathParse": {
      "type": "object",
      "properties": {
        "relativePathFromProjectRoot": {
          "type": "string",
          "description": "relative file or folder path from the project root"
        }
      },
      "required": [
        "relativePathFromProjectRoot"
      ],
      "additionalProperties": false,
      "description": "object to represent a folder or file path in different ways\n\nNB: doesn't include the absolute path so the indexes can be exported easily witout creating incorrect paths"
    },
    "PerformanceItem": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "durationMs": {
          "type": "number"
        }
      },
      "required": [
        "label",
        "durationMs"
      ],
      "additionalProperties": false
    },
    "ProjectType": {
      "type": "string",
      "enum": [
        "next",
        "react-native",
        "react",
        "express",
        "server",
        "unknown"
      ],
      "description": "DEPRECATED: TODO: should use OperationClassification"
    },
    "Schema": {
      "$ref": "#/definitions/JSONSchema7"
    },
    "SensibleConfig": {
      "type": "object",
      "properties": {
        "skipMinify": {
          "type": "boolean",
          "description": "put on to true if minify doesn't work, so it will be skipped by `rebuildOperation`"
        },
        "isSensibleProject": {
          "type": "boolean",
          "description": "If true, this is the root of a typerepo\n\nTODO: check if we can deprecate this"
        },
        "hasGeneratedDependencies": {
          "type": "boolean",
          "description": "If true, it means that this operation has dependency on one or more operations that have been generated. We need to know this because it can easily cause circular imports if we don't filter them out sometimes"
        },
        "appPort": {
          "type": "number",
          "description": "If the operation exposes an app on a port (can be both a server or frontend), we can specify the port it should run on.\n\nThis is especially useful to connect the port to something that's running.\n\nBy convention, for King OS, these ports should be unique and on the 42xx range"
        },
        "isNotSdkable": {
          "type": "boolean",
          "description": "If set to true, this operation will not be included into the SDKs"
        }
      },
      "additionalProperties": false,
      "description": "Sensible-global configurations\n\nTODO: rename to `typerepo`"
    },
    "SimplifiedSchemaItem": {
      "type": "object",
      "properties": {
        "name": {
          "type": [
            "string",
            "null"
          ],
          "description": "name in case of it being a reference, otherwise null"
        },
        "schema": {
          "$ref": "#/definitions/SimplifiedSchema"
        }
      },
      "required": [
        "name",
        "schema"
      ],
      "additionalProperties": false
    },
    "SimplifiedSchemaProperty": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "schema": {
          "$ref": "#/definitions/SimplifiedSchema"
        },
        "required": {
          "type": "boolean",
          "description": "NB: can't we put this in the SimplifiedSchema itself?"
        }
      },
      "required": [
        "name",
        "schema",
        "required"
      ],
      "additionalProperties": false
    },
    "SimplifiedSchemaType": {
      "type": "string",
      "enum": [
        "string",
        "number",
        "boolean",
        "object",
        "array",
        "null"
      ]
    },
    "SizeSummary": {
      "type": "object",
      "properties": {
        "numberOfFiles": {
          "type": "number",
          "description": "if this is about multiple files, the number of files is specified here"
        },
        "characters": {
          "type": "number",
          "description": "amount of characters"
        },
        "lines": {
          "type": "number",
          "description": "amount of lines"
        },
        "bytes": {
          "type": "number",
          "description": "amount of bytes"
        },
        "linesPerFile": {
          "type": "number",
          "description": "rounded, amount of lines per file (averaged)"
        },
        "charactersPerLine": {
          "type": "number",
          "description": "rounded, amount of characters per line (averaged)"
        },
        "bytesPerCharacter": {
          "type": "number",
          "description": "rounded, amount of bytes per character"
        }
      },
      "required": [
        "characters",
        "lines",
        "bytes",
        "linesPerFile",
        "charactersPerLine",
        "bytesPerCharacter"
      ],
      "additionalProperties": false,
      "description": "type interface that can be used to summarize multiple files"
    },
    "SocialMediaCallToAction": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      },
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "description": "A call to action suffix is a handy model that can be used to place under a postable. this way we are getting much more conversions from the traffic received on media"
    },
    "Stats": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "dev": {
          "type": "number"
        },
        "ino": {
          "type": "number"
        },
        "mode": {
          "type": "number"
        },
        "nlink": {
          "type": "number"
        },
        "uid": {
          "type": "number"
        },
        "gid": {
          "type": "number"
        },
        "rdev": {
          "type": "number"
        },
        "size": {
          "type": "number"
        },
        "blksize": {
          "type": "number"
        },
        "blocks": {
          "type": "number"
        },
        "atimeMs": {
          "type": "number"
        },
        "mtimeMs": {
          "type": "number"
        },
        "ctimeMs": {
          "type": "number"
        },
        "birthtimeMs": {
          "type": "number"
        },
        "atime": {
          "type": "string",
          "format": "date-time"
        },
        "mtime": {
          "type": "string",
          "format": "date-time"
        },
        "ctime": {
          "type": "string",
          "format": "date-time"
        },
        "birthtime": {
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "atime",
        "atimeMs",
        "birthtime",
        "birthtimeMs",
        "blksize",
        "blocks",
        "ctime",
        "ctimeMs",
        "dev",
        "gid",
        "ino",
        "mode",
        "mtime",
        "mtimeMs",
        "nlink",
        "rdev",
        "size",
        "uid"
      ],
      "description": "A `fs.Stats` object provides information about a file.\n\nObjects returned from  {@link  stat } ,  {@link  lstat }  and  {@link  fstat }  and their synchronous counterparts are of this type. If `bigint` in the `options` passed to those methods is true, the numeric values will be `bigint` instead of `number`, and the object will contain additional nanosecond-precision properties suffixed with `Ns`.\n\n```console Stats {   dev: 2114,   ino: 48064969,   mode: 33188,   nlink: 1,   uid: 85,   gid: 100,   rdev: 0,   size: 527,   blksize: 4096,   blocks: 8,   atimeMs: 1318289051000.1,   mtimeMs: 1318289051000.1,   ctimeMs: 1318289051000.1,   birthtimeMs: 1318289051000.1,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```\n\n`bigint` version:\n\n```console BigIntStats {   dev: 2114n,   ino: 48064969n,   mode: 33188n,   nlink: 1n,   uid: 85n,   gid: 100n,   rdev: 0n,   size: 527n,   blksize: 4096n,   blocks: 8n,   atimeMs: 1318289051000n,   mtimeMs: 1318289051000n,   ctimeMs: 1318289051000n,   birthtimeMs: 1318289051000n,   atimeNs: 1318289051000000000n,   mtimeNs: 1318289051000000000n,   ctimeNs: 1318289051000000000n,   birthtimeNs: 1318289051000000000n,   atime: Mon, 10 Oct 2011 23:24:11 GMT,   mtime: Mon, 10 Oct 2011 23:24:11 GMT,   ctime: Mon, 10 Oct 2011 23:24:11 GMT,   birthtime: Mon, 10 Oct 2011 23:24:11 GMT } ```"
    },
    "TextJson": {
      "type": "object",
      "properties": {
        "json": {
          "description": "only available if it's a json file"
        },
        "typescriptJson": {
          "description": "only available if it's a typescript file"
        },
        "markdownJson": {
          "$ref": "#/definitions/MarkdownParse",
          "description": "only available if it's a markdown file"
        },
        "path": {
          "type": "string",
          "description": "full path to the file or folder"
        },
        "isFolder": {
          "type": "boolean"
        },
        "stats": {
          "$ref": "#/definitions/Stats",
          "description": "DEPRECATED: to be replaced with metaData\n\nonly returned if this is requested"
        },
        "metaData": {
          "$ref": "#/definitions/PathMetaData",
          "description": "replaces stats. only returned if `includeMetaData` is set to true"
        },
        "isCancelRecursionResult": {
          "type": "boolean",
          "description": "if true, this means this path is given back because it was the last opened base path that searching was canceled on because of the cancelRecursionOn prop"
        }
      },
      "required": [
        "path",
        "isFolder"
      ],
      "additionalProperties": false
    },
    "TsConfig": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "include": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "exclude": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "compilerOptions": {
          "$ref": "#/definitions/CompilerOptions"
        }
      },
      "required": [
        "compilerOptions",
        "id",
        "operationName",
        "projectRelativePath"
      ],
      "additionalProperties": false,
      "description": "--- dbStorageMethod: jsonSingle operationRelativePath: tsconfig.json\n---\n\nwould be nice if we have a type interface for this, just like package.json for now just type the stuff we need"
    },
    "TsIndexModelType": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        }
      },
      "required": [
        "id",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false,
      "description": "identifier of any index type interface"
    },
    "TypeCoverage": {
      "type": "number",
      "description": "quantification of coverage of the specified type or subtypes in our database."
    },
    "TypeInfo": {
      "type": "object",
      "properties": {
        "typeDefinition": {
          "$ref": "#/definitions/Schema",
          "description": "JSON schema definition of a type interface\n\n\nSome info about the Schema:\n\n- if the type is an object, there should be properties\n- if the type is an array, there should be items"
        },
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        },
        "isObject": {
          "type": "boolean",
          "description": "if the type is an object, this is true. false if it's an array"
        },
        "isArray": {
          "type": "boolean",
          "description": "if the type is an array, this is true"
        },
        "isPrimitive": {
          "type": "boolean",
          "description": "if it's a primitive type like \"string\", \"number\", \"boolean\", \"null\" | \"undefined\""
        },
        "isEnum": {
          "type": "boolean",
          "description": "will be true for any primitive conjunction types"
        },
        "isEnumLiteral": {
          "type": "boolean",
          "description": "will be true for string conjunction types"
        },
        "typeCoverage": {
          "$ref": "#/definitions/TypeCoverage"
        },
        "rawType": {
          "type": "string",
          "description": "raw type string"
        }
      },
      "required": [
        "isObject",
        "isArray",
        "isPrimitive",
        "isEnum",
        "isEnumLiteral",
        "typeCoverage",
        "rawType"
      ],
      "additionalProperties": false,
      "description": "all info that should always be collected when indexing any type interface"
    },
    "TypescriptIndex": {
      "type": "object",
      "properties": {
        "tsBuildErrors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsBuildError"
          }
        },
        "tsLintWarnings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsLintWarning"
          }
        },
        "tsFunctions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "tsVariables": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsVariable"
          }
        },
        "tsInterfaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsInterface"
          }
        },
        "tsComments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          }
        },
        "tsImports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsImport"
          }
        },
        "tsExports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsExport"
          }
        }
      },
      "required": [
        "tsBuildErrors",
        "tsLintWarnings",
        "tsFunctions",
        "tsVariables",
        "tsInterfaces",
        "tsComments",
        "tsImports",
        "tsExports"
      ],
      "additionalProperties": false,
      "description": "--- isDbModel: false\n---\n\nTypescript file metadata (all indexes from typescript files, together)"
    },
    "WebMarkdownFile": {
      "type": "object",
      "properties": {
        "headerImage": {
          "$ref": "#/definitions/BackendAsset"
        },
        "headerTitle": {
          "type": "string"
        },
        "headerSubTitle": {
          "type": "string"
        },
        "headerCta": {
          "$ref": "#/definitions/MarkdownLink"
        },
        "createdAt": {
          "type": "number",
          "description": "Should be stored as textual date like `YYYY-MM-DD`"
        },
        "updatedAt": {
          "type": "number",
          "description": "Should be stored as textual date like `YYYY-MM-DD`"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "isDraft": {
          "type": "boolean",
          "description": "If true, will not show up in markdownReader ui's"
        },
        "privacy": {
          "type": "string",
          "enum": [
            "private",
            "request",
            "public"
          ],
          "description": "TODO: implement auth layers, then look at this again"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "description": "Either filled in or detected"
        },
        "isLanguageCustom": {
          "type": "boolean",
          "description": "If true, will not auto-detect the language"
        },
        "websiteCallToActionSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          }
        },
        "websiteCallToActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WebsiteCallToAction"
          }
        },
        "shop_itemIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          },
          "description": "Refers to an `Item` from the shop"
        },
        "author_personSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "Author, reference to persons"
        },
        "interestSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "Labels referring to interests"
        }
      },
      "required": [
        "author_personSlugs",
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "headerCta",
        "headerImage",
        "headerSubTitle",
        "headerTitle",
        "id",
        "interestSlugs",
        "language",
        "markdown",
        "name",
        "operationName",
        "privacy",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      },
      "description": "Every markdown file meant for the web, should have these optional parameters that can be declared as its frontmatter\n\nNB: This is not part of MarkdownModelType, because MarkdownModelType is very barebones general purpose, not only for the web!"
    },
    "WebsiteCallToAction": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "url": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "banner": {
          "type": "string"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "description",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "title",
        "updatedAt",
        "url"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "WebsiteHeader": {
      "type": "object",
      "properties": {
        "headerImage": {
          "$ref": "#/definitions/BackendAsset"
        },
        "headerTitle": {
          "type": "string"
        },
        "headerSubTitle": {
          "type": "string"
        },
        "headerCta": {
          "$ref": "#/definitions/MarkdownLink"
        }
      },
      "required": [
        "headerImage",
        "headerTitle",
        "headerSubTitle",
        "headerCta"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stripComment%3E": {
      "type": "object",
      "properties": {
        "rawCommentString": {
          "type": "string"
        }
      },
      "required": [
        "rawCommentString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stripCommentEnd%3E": {
      "type": "object",
      "properties": {
        "trimmedLine": {
          "type": "string"
        }
      },
      "required": [
        "trimmedLine"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stripCommentStart%3E": {
      "type": "object",
      "properties": {
        "trimmedLine": {
          "type": "string"
        }
      },
      "required": [
        "trimmedLine"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stripSlashes%3E": {
      "type": "object",
      "properties": {
        "trimmedLine": {
          "type": "string"
        }
      },
      "required": [
        "trimmedLine"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stripStar%3E": {
      "type": "object",
      "properties": {
        "trimmedLine": {
          "type": "string"
        }
      },
      "required": [
        "trimmedLine"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trim%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trimSurroundingNewlines%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getCompileErrors%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        },
        "onlyDependants": {
          "type": "boolean"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTypescriptErrorsFromFiles%3E": {
      "type": "object",
      "properties": {
        "{\n  filePaths,\n  debug,\n}": {
          "type": "object",
          "properties": {
            "basePath": {
              "type": "string"
            },
            "filePaths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "compilerOptions": {
              "$ref": "#/definitions/CompilerOptions"
            },
            "packageJson": {
              "$ref": "#/definitions/PackageJson"
            },
            "debug": {
              "type": "boolean"
            }
          },
          "required": [
            "basePath",
            "filePaths",
            "compilerOptions",
            "packageJson"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  filePaths,\n  debug,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof writeBuildErrors%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        },
        "operationManualProjectRoot": {
          "type": "string"
        },
        "typerepoManualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "Casing": {
      "type": "string",
      "enum": [
        "camel",
        "pascal",
        "snake",
        "kebab",
        "capital",
        "human"
      ]
    },
    "NamedParameters%3Ctypeof camelCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof capitalCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof capitaliseFirstLetter%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        }
      },
      "required": [
        "word"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof convertCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "NB: texts of more than a sentence are not supported"
        },
        "target": {
          "$ref": "#/definitions/Casing"
        }
      },
      "required": [
        "text",
        "target"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof convertToTargetCasing%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        },
        "index": {
          "type": "number"
        },
        "target": {
          "$ref": "#/definitions/Casing"
        }
      },
      "required": [
        "word",
        "index",
        "target"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDelimiter%3E": {
      "type": "object",
      "properties": {
        "target": {
          "$ref": "#/definitions/Casing"
        }
      },
      "required": [
        "target"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof humanCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof kebabCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof lowerCaseArray%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof pascalCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof slugify%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof snakeCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof splitCasingDelimiters%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        }
      },
      "required": [
        "word"
      ],
      "additionalProperties": false
    },
    "CsvItemType": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          },
          {
            "type": "null"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "NamedParameters%3Ctypeof tryParseCsv%3E": {
      "type": "object",
      "properties": {
        "csvString": {
          "type": "string"
        }
      },
      "required": [
        "csvString"
      ],
      "additionalProperties": false
    },
    "CustomQueryConfig": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string",
          "description": "if specified, this will be used as the root path to find your data in\n\nif not specified, uses the db folder in your project root and in any operation\n\nNB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries."
        },
        "operationName": {
          "type": [
            "string",
            "null"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        }
      },
      "additionalProperties": false,
      "description": "NB: the dbStorageMethod cannot be specified here because this is a static configuration per db-model and cannot be specified on a per-query basis.\n\nAlso you can't specify projectRelativePath and operationRelativePath. It should not be needed, you should specify the db storage locations in the createDb config."
    },
    "NamedParameters%3Ctypeof getCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMergedQueryConfig%3E": {
      "type": "object",
      "properties": {
        "modelName": {
          "type": "string",
          "enum": [
            "Todo",
            "Peer",
            "PeerMessage",
            "Platform",
            "Message",
            "MessageChannel",
            "MessagePreset",
            "Person",
            "PersonInformation",
            "PersonInformationValue",
            "Postable",
            "SocialMediaCredentail",
            "SocialMediaPost",
            "UserPersonPlatformConnection",
            "BundleConfig",
            "MarkdownFileConfig",
            "OperationConfig",
            "OperationIndex",
            "PackageJson",
            "SocialMediaCallToAction",
            "TsBuildError",
            "TsComment",
            "TsConfig",
            "TsExport",
            "TsFunction",
            "TsImport",
            "TsInterface",
            "TsLintWarning",
            "TsVariable",
            "WebsiteCallToAction",
            "Address",
            "Area",
            "City",
            "Country",
            "Location",
            "KvmdWord",
            "MarkdownWord",
            "NepaliEnglishTranslationMatrix",
            "Statement",
            "TokiPonaMatrix",
            "Translation",
            "Word",
            "WordCategory",
            "WordMatrix",
            "SlugModelType",
            "AppDeveloper",
            "Assignment",
            "Bag",
            "Calendar",
            "DataPoint",
            "Deliverable",
            "Diary",
            "Feeling",
            "FeelingLog",
            "Folder",
            "Host",
            "Inventory",
            "Item",
            "ItemCategory",
            "KvmdShortcut",
            "Label",
            "Light",
            "Listing",
            "LoginCredential",
            "Material",
            "ProgressReport",
            "Question",
            "Reservation",
            "Resource",
            "Shit",
            "ShitLog",
            "ShoppingList",
            "Shortcut",
            "Student",
            "Student2",
            "TaskError",
            "Thing",
            "TodoFile",
            "Trackable",
            "User",
            "UserCredential",
            "JeepType",
            "LocationType",
            "Activity",
            "CompanyRequirement",
            "CompanySize",
            "CompanyType",
            "Company",
            "ContactInformation",
            "Contribution",
            "EsgMetric",
            "ProductCategory",
            "Product",
            "ProofState",
            "Proof",
            "SustainabilityPlan",
            "ValueChainPhase"
          ]
        },
        "customQueryConfig": {
          "$ref": "#/definitions/CustomQueryConfig"
        }
      },
      "required": [
        "modelName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof main%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "CacheLookupResult": {
      "type": "object",
      "properties": {
        "hasValidCache": {
          "type": "boolean"
        },
        "result": {}
      },
      "required": [
        "hasValidCache"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof cacheLookup%3E": {
      "type": "object",
      "properties": {
        "functionName": {
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "functionName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof calculateOperatingSystemBundle%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getCachedFunctions%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDatabaseMenu%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "bundleId": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbModelNames%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "bundleId": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFunctionIndex%3E": {
      "type": "object",
      "properties": {
        "{\n  functionName,\n}": {
          "type": "object",
          "properties": {
            "functionName": {
              "type": "string"
            }
          },
          "required": [
            "functionName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  functionName,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNestedDatabaseMenu%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getReferencableModelData%3E": {
      "type": "object",
      "properties": {
        "dbModelName": {
          "type": "string",
          "enum": [
            "Device",
            "Group",
            "PageVisit",
            "PeerMessage",
            "Person",
            "PersonInformation",
            "PersonInformationValue",
            "PersonPlatformConnection",
            "Platform",
            "Interest",
            "MediaChannel",
            "MediaCredentail",
            "MediaPost",
            "Postable",
            "BundleConfig",
            "FunctionExecution",
            "MarkdownFileConfig",
            "OperationConfig",
            "OperationIndex",
            "PackageJson",
            "SocialMediaCallToAction",
            "TsBuildError",
            "TsComment",
            "TsConfig",
            "TsExport",
            "TsFunction",
            "TsImport",
            "TsInterface",
            "TsLintWarning",
            "TsVariable",
            "WebsiteCallToAction",
            "Address",
            "Area",
            "City",
            "Country",
            "Location",
            "KvmdWord",
            "MarkdownWord",
            "NepaliEnglishTranslationMatrix",
            "Statement",
            "TokiPonaMatrix",
            "Translation",
            "Word",
            "WordCategory",
            "WordMatrix",
            "SlugModelType",
            "AppDeveloper",
            "Assignment",
            "Bag",
            "Calendar",
            "DataPoint",
            "Deliverable",
            "Diary",
            "Feeling",
            "FeelingLog",
            "Folder",
            "Host",
            "Inventory",
            "Item",
            "ItemCategory",
            "KvmdShortcut",
            "Label",
            "Light",
            "Listing",
            "LoginCredential",
            "Material",
            "MessagePreset",
            "ProgressReport",
            "Question",
            "Reservation",
            "Resource",
            "Shit",
            "ShitLog",
            "ShoppingList",
            "Shortcut",
            "Student",
            "Student2",
            "TaskError",
            "Thing",
            "TodoFile",
            "Trackable",
            "User",
            "UserCredential",
            "JeepType",
            "LocationType",
            "Activity",
            "CompanyRequirement",
            "CompanySize",
            "CompanyType",
            "Company",
            "ContactInformation",
            "Contribution",
            "EsgMetric",
            "ProductCategory",
            "Product",
            "ProofState",
            "Proof",
            "SustainabilityPlan",
            "ValueChainPhase"
          ]
        }
      },
      "required": [
        "dbModelName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof hasDbRecipes%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeSrcRelativeFolder%3E": {
      "type": "object",
      "properties": {
        "operationRelativeTypescriptFilePath": {
          "type": "string"
        }
      },
      "required": [
        "operationRelativeTypescriptFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tsInterfaceToDbMenu%3E": {
      "type": "object",
      "properties": {
        "tsInterface": {
          "$ref": "#/definitions/TsInterface"
        },
        "type": {
          "type": "string"
        }
      },
      "required": [
        "tsInterface",
        "type"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof validateInput%3E": {
      "type": "object",
      "properties": {
        "functionName": {
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {}
        },
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        }
      },
      "required": [
        "functionName",
        "tsFunction"
      ],
      "additionalProperties": false
    },
    "NestedDatabaseMenu": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/NestedObject"
          },
          {
            "type": [
              "object",
              "null"
            ]
          }
        ]
      },
      "properties": {},
      "description": "This is a simple overwrite of the `NestedPathObject` with a more specific key naming.\n\nI can use this directly to render a menu with many layers!\n\nSUPER COOL"
    },
    "NamedParameters%3Ctypeof filterInterfacesFromOperationNames%3E": {
      "type": "object",
      "properties": {
        "tsInterface": {
          "$ref": "#/definitions/TsInterface"
        },
        "operationNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "tsInterface"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbModelsFromOperations%3E": {
      "type": "object",
      "properties": {
        "operationNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "operationNames"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof FancyLoader%3E": {
      "type": "object",
      "properties": {
        "{\n  big,\n  medium,\n}": {
          "type": "object",
          "properties": {
            "big": {
              "type": "boolean"
            },
            "medium": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  big,\n  medium,\n}"
      ],
      "additionalProperties": false
    },
    "DropboxExtension": {
      "type": "string",
      "enum": [
        "doc",
        "docx",
        "csv",
        "xls",
        "xlsx",
        "epub",
        "pdf"
      ],
      "description": "these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored."
    },
    "FileType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "filename including extension"
        },
        "size": {
          "type": "number",
          "description": "size in bytes"
        },
        "mtime_ms": {
          "type": "number",
          "description": "unix timestamp in ms"
        },
        "exists": {
          "type": "boolean",
          "description": "whether the file still exists"
        },
        "type": {
          "type": "string",
          "description": "f stands for file, it seems, for the rest I don't know"
        }
      },
      "required": [
        "name",
        "size",
        "mtime_ms",
        "exists",
        "type"
      ],
      "additionalProperties": false
    },
    "JsonExtension": {
      "type": "string"
    },
    "MarkdownExtension": {
      "type": "string"
    },
    "NamedParameters%3Ctypeof getWriterType%3E": {
      "type": "object",
      "properties": {
        "extension": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof hasSubExtension%3E": {
      "type": "object",
      "properties": {
        "srcRelativeFileId": {
          "type": "string"
        },
        "subExtensions": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "includeRootName": {
          "type": "boolean",
          "description": "if true, also returns true if the extension is the complete name of the file"
        }
      },
      "required": [
        "srcRelativeFileId",
        "subExtensions"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isGeneratedOperation%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isGeneratedOperationName%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isIndexableFileId%3E": {
      "type": "object",
      "properties": {
        "fileId": {
          "type": "string"
        }
      },
      "required": [
        "fileId"
      ],
      "additionalProperties": false
    },
    "SearchableExtension": {
      "anyOf": [
        {
          "$ref": "#/definitions/TypescriptExtension"
        },
        {
          "$ref": "#/definitions/MarkdownExtension"
        },
        {
          "$ref": "#/definitions/JsonExtension"
        }
      ]
    },
    "SearchLevel": {
      "type": "string",
      "enum": [
        "folder",
        "fileName",
        "filePath",
        "outline",
        "full"
      ]
    },
    "TypescriptExtension": {
      "type": "string"
    },
    "WriterType": {
      "type": "string",
      "enum": [
        "typescript",
        "markdown",
        "other"
      ],
      "description": "Type of content that can be interpreted by the `writer-input`"
    },
    "NamedParameters%3Ctypeof findDependantsRecursivelyTest%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof test2%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof folderGetUpdatedAt%3E": {
      "type": "object",
      "properties": {
        "{\n  folderPath,\n}": {
          "type": "object",
          "properties": {
            "folderPath": {
              "type": "string"
            }
          },
          "required": [
            "folderPath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  folderPath,\n}"
      ],
      "additionalProperties": false
    },
    "AnyModelObject": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/AugmentedAnyModelType"
      }
    },
    "AugmentedAnyModelType": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        }
      },
      "required": [
        "id",
        "operationName",
        "projectRelativePath"
      ]
    },
    "DbFileLocation": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "absolutePath": {
          "type": "string"
        },
        "modelName": {
          "type": "string"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        }
      },
      "required": [
        "absolutePath",
        "modelName",
        "operationName",
        "projectRelativePath"
      ],
      "description": "Object used to hand over all information about the location of a db-file in a structured way"
    },
    "DbQueryResult": {
      "type": "object",
      "properties": {
        "isSuccesful": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        },
        "isNewFile": {
          "type": "boolean"
        },
        "amountInserted": {
          "type": "number"
        },
        "amountUpdated": {
          "type": "number"
        },
        "amountRemoved": {
          "type": "number"
        }
      },
      "additionalProperties": false,
      "description": "TODO: return the inserted id or other reference\n\nResult of any query except `get`. Will not always provide all parameters (depends on the type of query you do)"
    },
    "IncludeConfig": {
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "auto": {
              "type": "boolean",
              "description": "NOT SUPPORTED YET\n\nIf this is set to true, regular include will be ignored. More depth is not possible.\n\nYou can simply specify `auto: true`. This is the easiest way to include. This will fetch all references in the model for every item in an as efficient way as possible, but only with a depth of 1.\n\nAssumptions:\n\n1) The first item in the db contains all reference-keys that need to be filled. Keys not present in the first item will not be filled"
            },
            "referenceKey": {
              "type": "string",
              "description": "The key that contains a reference. The name of this key should follow the convention, e.g. `xxxSlug`. If this is given, `xxx` will be filled with the item of the referenced model."
            },
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AugmentedAnyModelType"
              },
              "description": "If provided, the items will be filled from this array. If not provided, the required model will first be fetched using get. It is often more efficient to provide it yourself if you have already fetched it anyway. Nonetheless, `fs-orm` will try and reuse the fetched data to minimize amount of reads to the file system."
            },
            "include": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Include"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Include"
                  }
                }
              ],
              "description": "Optionally, you can provide another include config for this model"
            }
          }
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Include"
          }
        }
      ],
      "description": "All possible ways to include items from references into a get query"
    },
    "IncludeDataObject": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/AugmentedAnyModelType"
        }
      }
    },
    "Include": {
      "type": "object",
      "properties": {
        "referenceKey": {
          "type": "string",
          "description": "The key that contains a reference. The name of this key should follow the convention, e.g. `xxxSlug`. If this is given, `xxx` will be filled with the item of the referenced model."
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AugmentedAnyModelType"
          },
          "description": "If provided, the items will be filled from this array. If not provided, the required model will first be fetched using get. It is often more efficient to provide it yourself if you have already fetched it anyway. Nonetheless, `fs-orm` will try and reuse the fetched data to minimize amount of reads to the file system."
        },
        "include": {
          "anyOf": [
            {
              "$ref": "#/definitions/Include"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Include"
              }
            }
          ],
          "description": "Optionally, you can provide another include config for this model"
        }
      },
      "additionalProperties": false
    },
    "KeyValueMarkdownModelType": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        }
      },
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false,
      "description": "handy model type for storing stuff in a KeyValue Markdown file. empty lines are omitted\n\nall you need to specify in the kvmd is the key and the value, separated by \":\"\n\nNB: there can be a `parent_modelNameSlug` key exposed that should refer to the parent slug"
    },
    "MergedQueryConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod",
          "description": "When setting this, make sure your models are able to use this storage method, this is not always possible!\n\ndefaults to jsonMultiple"
        },
        "manualProjectRoot": {
          "type": "string",
          "description": "if specified, this will be used as the root path to find your data in\n\nif not specified, uses the db folder in your project root and in any operation\n\nNB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries."
        },
        "operationName": {
          "type": [
            "string",
            "null"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "if specified, only this location will be used"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "if specified, only this location will be used (also need an `operationName`)"
        }
      },
      "required": [
        "dbStorageMethod",
        "manualProjectRoot"
      ]
    },
    "ModelLocation": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        }
      },
      "required": [
        "operationName",
        "projectRelativePath"
      ],
      "additionalProperties": false,
      "description": "Parameters that tell you about the location an instance of a model. Models can be tied to an operation. They always have a `projectRelativePath`, and if they are tied to an operation, also an `operationRelativePath`."
    },
    "NamedParameters%3Ctypeof augmentItemWithReferencedDataRecursively%3E": {
      "type": "object",
      "properties": {
        "item": {
          "$ref": "#/definitions/AugmentedAnyModelType"
        },
        "includeArray": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Include"
          }
        },
        "includeData": {
          "$ref": "#/definitions/IncludeDataObject",
          "description": "Final includeData object to take items from"
        }
      },
      "required": [
        "item",
        "includeArray",
        "includeData"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof calculateOperationsObject%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "manualProjectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findParent%3E": {
      "type": "object",
      "properties": {
        "arrayItem": {
          "$ref": "#/definitions/Storing%3CKeyValueMarkdownModelType%3E"
        },
        "newCategoryStack": {
          "$ref": "#/definitions/CategoryStack"
        }
      },
      "required": [
        "arrayItem",
        "newCategoryStack"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAugmentedData%3E": {
      "type": "object",
      "properties": {
        "dbFileLocation": {
          "$ref": "#/definitions/DbFileLocation"
        },
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod"
        }
      },
      "required": [
        "dbFileLocation",
        "dbStorageMethod"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDatabaseFiles%3E": {
      "type": "object",
      "properties": {
        "modelName": {
          "type": "string"
        },
        "mergedConfig": {
          "$ref": "#/definitions/MergedQueryConfig"
        }
      },
      "required": [
        "modelName",
        "mergedConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDatabaseRootFolder%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "string",
            "null"
          ]
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbFileLocation%3E": {
      "type": "object",
      "properties": {
        "storedItem": {
          "$ref": "#/definitions/Storing%3CAugmentedAnyModelType%3E",
          "description": "The ModelLocation properties in the item are completely ignored.\n\nOnly the ID, slug and categoryStackCalculated are used to determine the exact file the item should be stored in.\n\nNB: storedItem MUST have a slug or ID, but this should probably be generated before this funciton"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "Should be the operationName from the modellocation of the actual item.\n\nIf it is given, this will take priority over the merged query config."
        },
        "mergedConfig": {
          "$ref": "#/definitions/MergedQueryConfig"
        },
        "modelName": {
          "type": "string"
        }
      },
      "required": [
        "storedItem",
        "operationName",
        "mergedConfig",
        "modelName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbStorageMethodExtension%3E": {
      "type": "object",
      "properties": {
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod"
        }
      },
      "required": [
        "dbStorageMethod"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getLocationPattern%3E": {
      "type": "object",
      "properties": {
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod"
        },
        "modelName": {
          "type": "string"
        },
        "mergedConfig": {
          "$ref": "#/definitions/MergedQueryConfig"
        }
      },
      "required": [
        "dbStorageMethod",
        "modelName",
        "mergedConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParentSlug%3E": {
      "type": "object",
      "properties": {
        "item": {
          "$ref": "#/definitions/Storing%3CKeyValueMarkdownModelType%3E"
        }
      },
      "required": [
        "item"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getWildcardDbFileLocations__OLD%3E": {
      "type": "object",
      "properties": {
        "options": {
          "type": "object",
          "properties": {
            "modelName": {
              "type": "string"
            },
            "parsedPath": {
              "$ref": "#/definitions/path.ParsedPath"
            },
            "operationName": {
              "type": [
                "string",
                "null"
              ]
            },
            "projectRoot": {
              "type": "string"
            },
            "rootFolder": {
              "$ref": "#/definitions/RootDbFolder"
            }
          },
          "required": [
            "modelName",
            "parsedPath",
            "operationName",
            "projectRoot",
            "rootFolder"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "options"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getWildcardDbFileLocations%3E": {
      "type": "object",
      "properties": {
        "options": {
          "type": "object",
          "properties": {
            "modelName": {
              "type": "string"
            },
            "parsedPath": {
              "$ref": "#/definitions/path.ParsedPath"
            },
            "operationName": {
              "type": [
                "string",
                "null"
              ]
            },
            "projectRoot": {
              "type": "string"
            },
            "rootFolder": {
              "$ref": "#/definitions/RootDbFolder"
            }
          },
          "required": [
            "modelName",
            "parsedPath",
            "operationName",
            "projectRoot",
            "rootFolder"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "options"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeKeyValueMarkdown%3E": {
      "type": "object",
      "properties": {
        "storedData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Storing%3CKeyValueMarkdownModelType%3E"
          }
        },
        "slug": {
          "type": "string",
          "description": "slug to remove"
        }
      },
      "required": [
        "storedData",
        "slug"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof upsertKeyValueMarkdown%3E": {
      "type": "object",
      "properties": {
        "storedData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Storing%3CKeyValueMarkdownModelType%3E"
          }
        },
        "storingItem": {
          "$ref": "#/definitions/Storing%3CKeyValueMarkdownModelType%3E"
        }
      },
      "required": [
        "storedData",
        "storingItem"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof upsert%3E": {
      "type": "object",
      "properties": {
        "storedData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Storing%3CAugmentedAnyModelType%3E"
          },
          "description": "The items that were already there"
        },
        "storingItems": {
          "anyOf": [
            {
              "$ref": "#/definitions/Storing%3CAugmentedAnyModelType%3E"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Storing%3CAugmentedAnyModelType%3E"
              }
            }
          ],
          "description": "The items that need to be overwritten or inserted"
        },
        "onlyInsert": {
          "type": "boolean",
          "description": "If true, the upserting will fail if there are occuring items with equal slugs/ids"
        }
      },
      "required": [
        "storedData",
        "storingItems"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addDefaultValues%3E": {
      "type": "object",
      "properties": {
        "bareItem": {
          "$ref": "#/definitions/Creation%3CAugmentedAnyModelType%3E"
        },
        "isKvmdStorage": {
          "type": "boolean"
        }
      },
      "required": [
        "bareItem"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof createDb%3E": {
      "type": "object",
      "properties": {
        "dbConfig": {
          "$ref": "#/definitions/DbConfig%3C%3E"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDefaultLocationPattern%3E": {
      "type": "object",
      "properties": {
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod"
        },
        "modelName": {
          "type": "string"
        }
      },
      "required": [
        "dbStorageMethod",
        "modelName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMergedConfigOperationPath%3E": {
      "type": "object",
      "properties": {
        "mergedConfig": {
          "$ref": "#/definitions/MergedQueryConfig"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "mergedConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getRootFolders%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "projectRoot": {
              "type": "string"
            },
            "mergedConfig": {
              "$ref": "#/definitions/MergedQueryConfig"
            },
            "operationPath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "boolean",
                  "const": false
                }
              ]
            }
          },
          "required": [
            "projectRoot",
            "mergedConfig",
            "operationPath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "QueryConfig": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": [
            "string",
            "null"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "if specified, only this location will be used"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "if specified, only this location will be used (also need an `operationName`)"
        },
        "dbStorageMethod": {
          "$ref": "#/definitions/DbStorageMethod",
          "description": "When setting this, make sure your models are able to use this storage method, this is not always possible!\n\ndefaults to jsonMultiple"
        },
        "manualProjectRoot": {
          "type": "string",
          "description": "if specified, this will be used as the root path to find your data in\n\nif not specified, uses the db folder in your project root and in any operation\n\nNB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries."
        }
      },
      "additionalProperties": false,
      "description": "QueryConfig is set on 4 levels, which have increasing priority\n\n- hardcoded in `fs-orm`\n- when calling `createDb`, setting `defaultQueryConfig`\n- when calling `createDb`, setting `modelQueryConfig`\n- when running a query\n\nNot all options are available when running a query."
    },
    "RootDbFolder": {
      "type": "object",
      "properties": {
        "basePath": {
          "type": "string",
          "description": "is an operation Base path in case of operationName is not null"
        },
        "operationName": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "basePath",
        "operationName"
      ],
      "additionalProperties": false
    },
    "UpsertKeyValueMarkdownItem": {
      "type": "object",
      "properties": {
        "parameters": {
          "anyOf": [
            {
              "$ref": "#/definitions/Frontmatter"
            },
            {
              "type": "null"
            }
          ]
        },
        "item": {
          "$ref": "#/definitions/KeyValueMarkdownModelType"
        }
      },
      "required": [
        "parameters",
        "item"
      ],
      "additionalProperties": false
    },
    "UpsertQueryConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "removeUntouched": {
          "type": "boolean",
          "description": "Special config for upsert. If you set this to true, all items in the databasefiles that were altered that you didn't specify in the items, will be removed."
        },
        "onlyInsert": {
          "type": "boolean",
          "description": "If true, the query will fail if the slug or id already exists (normally this means upsert will update that value)\n\nNB: not supported for keyValueMarkdown"
        },
        "manualProjectRoot": {
          "type": "string",
          "description": "if specified, this will be used as the root path to find your data in\n\nif not specified, uses the db folder in your project root and in any operation\n\nNB: If you set this, the model interfaces of your current project are applied on another project! Make sure they are the same there before you run such queries."
        },
        "operationName": {
          "type": [
            "string",
            "null"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        }
      }
    },
    "Dir": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "The read-only path of this directory as was provided to  {@link  opendir } , {@link  opendirSync } , or `fsPromises.opendir()`."
        }
      },
      "required": [
        "path"
      ],
      "additionalProperties": false,
      "description": "A class representing a directory stream.\n\nCreated by  {@link  opendir } ,  {@link  opendirSync } , or `fsPromises.opendir()`.\n\n```js import { opendir } from 'fs/promises';\n\ntry {   const dir = await opendir('./');   for await (const dirent of dir)     console.log(dirent.name); } catch (err) {   console.error(err); } ```\n\nWhen using the async iterator, the `fs.Dir` object will be automatically closed after the iterator exits."
    },
    "Dirent": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The file name that this `fs.Dirent` object refers to. The type of this value is determined by the `options.encoding` passed to  {@link  readdir }  or  {@link  readdirSync } ."
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false,
      "description": "A representation of a directory entry, which can be a file or a subdirectory within the directory, as returned by reading from an `fs.Dir`. The directory entry is a combination of the file name and file type pairs.\n\nAdditionally, when  {@link  readdir }  or  {@link  readdirSync }  is called with the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s."
    },
    "FolderPath": {
      "type": "object",
      "properties": {
        "relativeFolder": {
          "type": "string"
        },
        "path": {
          "$ref": "#/definitions/Path"
        }
      },
      "required": [
        "path"
      ],
      "additionalProperties": false,
      "description": "DEPRECATED: just use ParsedPath"
    },
    "Fs": {
      "type": "object",
      "properties": {
        "PathLike": {
          "$ref": "#/definitions/PathLike"
        },
        "Stats": {
          "$ref": "#/definitions/Stats"
        },
        "Dir": {
          "$ref": "#/definitions/Dir"
        },
        "Dirent": {
          "$ref": "#/definitions/Dirent"
        }
      },
      "required": [
        "PathLike",
        "Stats",
        "Dir",
        "Dirent"
      ],
      "additionalProperties": false,
      "description": "all handy Fs types"
    },
    "MarkdownContent": {
      "type": "string"
    },
    "NamedParameters%3Ctypeof findFileNameCaseInsensitive%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        },
        "fileName": {
          "type": "string",
          "description": "fileName with extension"
        }
      },
      "required": [
        "folderPath",
        "fileName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFileName%3E": {
      "type": "object",
      "properties": {
        "pathString": {
          "type": "string"
        }
      },
      "required": [
        "pathString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFolder%3E": {
      "type": "object",
      "properties": {
        "pathString": {
          "type": "string"
        }
      },
      "required": [
        "pathString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getLastFolder%3E": {
      "type": "object",
      "properties": {
        "pathString": {
          "type": "string"
        }
      },
      "required": [
        "pathString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPathCombinations%3E": {
      "type": "object",
      "properties": {
        "chunksSegments": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "required": [
        "chunksSegments"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseMd%3E": {
      "type": "object",
      "properties": {
        "mdFilePath": {
          "$ref": "#/definitions/Path",
          "description": "path to a md file"
        }
      },
      "required": [
        "mdFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeAllExcept%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        },
        "config": {
          "type": "object",
          "properties": {
            "ignore": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "array of relative folder paths and file paths that should not be removed (include the extensions!)"
            },
            "typeToRemove": {
              "type": "string",
              "enum": [
                "file",
                "folder"
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "folderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof copyAllRelativeFiles%3E": {
      "type": "object",
      "properties": {
        "relativeFilePaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "absoluteSourceRoot": {
          "type": "string"
        },
        "absoluteDestinationRoot": {
          "type": "string"
        },
        "force": {
          "type": "boolean",
          "description": "Overwrite existing file or directory"
        }
      },
      "required": [
        "relativeFilePaths",
        "absoluteSourceRoot",
        "absoluteDestinationRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllFoldersUntilFolder%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        }
      },
      "required": [
        "folderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFirstAvailableFilename%3E": {
      "type": "object",
      "properties": {
        "absoluteFilePath": {
          "type": "string"
        }
      },
      "required": [
        "absoluteFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOneFolderUpPath%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        }
      },
      "required": [
        "folderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof oneUp%3E": {
      "type": "object",
      "properties": {
        "filename": {
          "type": "string"
        }
      },
      "required": [
        "filename"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renameAndCreate%3E": {
      "type": "object",
      "properties": {
        "oldPath": {
          "type": "string"
        },
        "newPath": {
          "type": "string"
        }
      },
      "required": [
        "oldPath",
        "newPath"
      ],
      "additionalProperties": false
    },
    "PathLike": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/definitions/global.Buffer"
        },
        {
          "$ref": "#/definitions/URL"
        }
      ],
      "description": "Valid types for path values in \"fs\"."
    },
    "Path": {
      "type": "string",
      "description": "unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything."
    },
    "UnixTimestamp": {
      "type": "number"
    },
    "NamedParameters%3Ctypeof join%3E": {
      "type": "object",
      "properties": {
        "chunks": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "chunks"
      ],
      "additionalProperties": false
    },
    "IPInfo": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string",
          "description": "The ip of the device. Can be a local IP or remote IP.\n\nNB: Port is not included"
        },
        "city": {
          "type": "string"
        },
        "position": {
          "$ref": "#/definitions/Position"
        },
        "positionRadiusKm": {
          "type": "number"
        },
        "country": {
          "type": "string"
        },
        "region": {
          "type": "string"
        },
        "timezone": {
          "type": "string"
        }
      },
      "required": [
        "ip"
      ],
      "additionalProperties": false,
      "description": "Information that is inferred from an IP"
    },
    "NamedParameters%3Ctypeof calculateDeviceName%3E": {
      "type": "object",
      "properties": {
        "ipInfo": {
          "$ref": "#/definitions/IPInfo"
        },
        "userAgent": {
          "$ref": "#/definitions/UAParser.IResult"
        }
      },
      "required": [
        "ipInfo",
        "userAgent"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof cleanupTimer%3E": {
      "type": "object",
      "properties": {
        "uniqueId": {
          "type": "string"
        }
      },
      "required": [
        "uniqueId"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNewPerformance%3E": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "uniqueId": {
          "type": "string"
        },
        "isNew": {
          "type": "boolean"
        }
      },
      "required": [
        "label",
        "uniqueId"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTsFunction%3E": {
      "type": "object",
      "properties": {
        "functionName": {
          "type": "string"
        }
      },
      "required": [
        "functionName"
      ],
      "additionalProperties": false
    },
    "FnMatch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "type": "string",
          "description": "unique id of the model"
        },
        "name": {
          "type": "string",
          "description": "name (identifier) of the model"
        },
        "slug": {
          "type": "string",
          "description": "kebab-case variant of the name"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)"
        },
        "isGetApi": {
          "type": "boolean",
          "description": "if true, the function will get the `server`.js context as its only argument, and it's directly exposed as GET api. Endpoint path will be inferred from the function name\n\nFor this to be indexed to `true`, you need to call the function `abcXyzGetApi` whhere `abcXyz` can be anything."
        },
        "isPostApi": {
          "type": "boolean",
          "description": "If true, the function will get the `server`.js context as its only argument, and it's directly exposed as POST api. Endpoint path will be inferred from the function name\n\nFor this to be indexed to `true`, you need to call the function `abcXyzPostApi` where `abcXyz` can be anything."
        },
        "isExported": {
          "type": "boolean",
          "description": "The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation"
        },
        "isApiExposed": {
          "type": "boolean",
          "description": "for all exported functions in node operations, true by default false for others\n\ncan be overwritten using frontmatter"
        },
        "publicAuthorization": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthorizationLevel"
          },
          "description": "The default authorization that is set level applies to users without any specific authorization (granted to everyone)."
        },
        "runEveryPeriod": {
          "$ref": "#/definitions/RunEveryPeriodEnum",
          "description": "You can specify `runEveryPeriod` in your frontmatter of a function. This will set `runEveryPeriod` for the TsFunction. This is used by `function-server`: it will execute CRON-jobs that run these things on those periods.\n\nWill only work if the function takes no arguments."
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "parsed comment from doc-comment"
        },
        "rawText": {
          "type": "string",
          "description": "raw text of the function"
        },
        "commentsInside": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsComment"
          },
          "description": "all comments found in a function and the node that they belong to"
        },
        "returnType": {
          "$ref": "#/definitions/TypeInfo",
          "description": "return type JSON Schema definition"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FunctionParameter"
          },
          "description": "parameters the function takes as its arguments, if any"
        },
        "size": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of this function (comments + code)"
        },
        "commentSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of the comments of this function (including surrounding comments)"
        },
        "codeSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "size of the code inside the function (without comments)"
        },
        "cumulativeSize": {
          "$ref": "#/definitions/SizeSummary",
          "description": "tells you the size of itself and all its dependencies that are used that are also part of an operation, recursively"
        },
        "cumulativeCommentSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "cumulativeCodeSize": {
          "$ref": "#/definitions/SizeSummary"
        },
        "maxIndentationDepth": {
          "type": "number",
          "description": "maximum amount of times indedented in this function\n\ngood for determining the complexity and finding code that can be simplified/destructured into smaller pieces"
        },
        "dependantFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "finds all files that import this function\n\nNB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly."
        },
        "matcher": {
          "type": "string"
        },
        "relativeOperationPath": {
          "type": "string"
        }
      },
      "required": [
        "commentsInside",
        "id",
        "isApiExposed",
        "isExported",
        "matcher",
        "maxIndentationDepth",
        "name",
        "operationName",
        "operationRelativeTypescriptFilePath",
        "projectRelativePath",
        "publicAuthorization",
        "relativeOperationPath",
        "returnType",
        "size",
        "slug"
      ]
    },
    "NamedParameters%3Ctypeof chat%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof converse%3E": {
      "type": "object",
      "properties": {
        "searchMessage": {
          "type": "string"
        }
      },
      "required": [
        "searchMessage"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof doCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof executeSdkFunction%3E": {
      "type": "object",
      "properties": {
        "operationString": {
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "operationString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getCachedExportedFunctions%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMenu%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParameters%3E": {
      "type": "object",
      "properties": {
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FunctionParameter"
          }
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParametersAndExecute%3E": {
      "type": "object",
      "properties": {
        "fn": {
          "$ref": "#/definitions/FnMatch"
        }
      },
      "required": [
        "fn"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSdkFunctionPaths%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSdkKeys%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof listen%3E": {
      "type": "object",
      "properties": {
        "{\n  instruction,\n  context,\n}": {
          "type": "object",
          "properties": {
            "instruction": {
              "type": "string"
            },
            "context": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "instruction": {
                    "type": "string"
                  },
                  "output": {},
                  "references": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "instruction",
                  "output",
                  "references"
                ],
                "additionalProperties": false,
                "description": "need to find a good way to save results of previous instructions"
              },
              "description": "should be in fifo order, so no push but unshift! the further in the array, the less important the context (forgetting)"
            }
          },
          "required": [
            "instruction",
            "context"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  instruction,\n  context,\n}"
      ],
      "additionalProperties": false
    },
    "ImportStatement": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "variable",
            "function",
            "interface"
          ]
        },
        "name": {
          "type": "string"
        },
        "srcRelativeFileId": {
          "type": "string"
        }
      },
      "required": [
        "type",
        "name",
        "srcRelativeFileId"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateNamedIndex%3E": {
      "type": "object",
      "properties": {
        "{\n  operationName,\n  manualProjectRoot,\n}": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "operationName": {
              "type": "string"
            }
          },
          "required": [
            "operationName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationName,\n  manualProjectRoot,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateSimpleIndex%3E": {
      "type": "object",
      "properties": {
        "{\n  operationName,\n  manualProjectRoot,\n}": {
          "type": "object",
          "properties": {
            "operationName": {
              "type": "string",
              "description": "if given, just exports * from those"
            },
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "required": [
            "operationName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationName,\n  manualProjectRoot,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isTestFn%3E": {
      "type": "object",
      "properties": {
        "x": {
          "$ref": "#/definitions/ImportStatement"
        }
      },
      "required": [
        "x"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mapToImportStatement%3E": {
      "type": "object",
      "properties": {
        "item": {
          "anyOf": [
            {
              "$ref": "#/definitions/TsFunction"
            },
            {
              "$ref": "#/definitions/TsVariable"
            },
            {
              "$ref": "#/definitions/TsInterface"
            }
          ]
        },
        "type": {
          "type": "string",
          "enum": [
            "variable",
            "function",
            "interface"
          ]
        }
      },
      "required": [
        "item",
        "type"
      ],
      "additionalProperties": false
    },
    "FunctionsPerClassification": {
      "type": "object",
      "properties": {
        "js": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "ts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "node": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "server": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "web": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "app": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "ui-es6": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "ui-es5": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "ui-esm": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        }
      },
      "required": [
        "js",
        "ts",
        "node",
        "server",
        "web",
        "app",
        "ui-es6",
        "ui-es5",
        "ui-esm"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateEnvSdks%3E": {
      "type": "object",
      "properties": {
        "bundleConfig": {
          "$ref": "#/definitions/BundleConfig"
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "bundleConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateEnvSdksCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateFunctionPathsSdk%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateFunctionSdks%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateFunctionSdksCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateOperationsSdk%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateOperationsSdkCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSdkDescription%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSdkFunctions%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isTsFunctionIndexable%3E": {
      "type": "object",
      "properties": {
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        }
      },
      "required": [
        "tsFunction"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newEnvSdk%3E": {
      "type": "object",
      "properties": {
        "bundleConfig": {
          "$ref": "#/definitions/BundleConfig",
          "description": "NB: if this is not a bundle, a more general purpose bundle config should be used"
        },
        "type": {
          "type": "string",
          "enum": [
            "public",
            "private"
          ]
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "bundleConfig",
        "type"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newSdkKeysOperation%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "keyVariables": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "variableName": {
                "type": "string"
              },
              "values": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "variableName",
              "values"
            ],
            "additionalProperties": false
          }
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "operationName",
        "keyVariables"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newSdkOperation%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "tsFunctions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "skipYarnInstall": {
              "type": "boolean"
            },
            "dryrun": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "operationName",
        "tsFunctions"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tsFunctionIsSdkable%3E": {
      "type": "object",
      "properties": {
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        },
        "operationClassificationObject": {
          "$ref": "#/definitions/OperationClassificationObject"
        },
        "operationClassification": {
          "$ref": "#/definitions/OperationClassification"
        }
      },
      "required": [
        "tsFunction",
        "operationClassificationObject",
        "operationClassification"
      ],
      "additionalProperties": false
    },
    "OperationClassificationObject": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/OperationClassification"
      }
    },
    "Address": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "locationSlug": {
          "$ref": "#/definitions/Slug"
        },
        "location": {
          "$ref": "#/definitions/Location"
        },
        "postalCode": {
          "type": "string"
        },
        "street": {
          "type": "string"
        },
        "houseNumber": {
          "type": "string"
        },
        "area": {
          "$ref": "#/definitions/Area"
        },
        "description": {
          "$ref": "#/definitions/Markdown"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "houseNumber",
        "id",
        "language",
        "locationSlug",
        "name",
        "operationName",
        "postalCode",
        "projectRelativePath",
        "slug",
        "street",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "Area": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "polygon": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Position"
          }
        },
        "circles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Circle"
          }
        },
        "center": {
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number"
            },
            "longitude": {
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "additionalProperties": false
        }
      },
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "description": "in the UI this should be a special input type, where you can draw a polygon or circles on the map and the center will be calculated"
    },
    "Circle": {
      "type": "object",
      "properties": {
        "diameterMeters": {
          "type": "number"
        },
        "position": {
          "$ref": "#/definitions/Position"
        }
      },
      "required": [
        "diameterMeters",
        "position"
      ],
      "additionalProperties": false
    },
    "City": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        },
        "population": {
          "type": "number"
        },
        "countrySlug": {
          "$ref": "#/definitions/Slug"
        },
        "country": {
          "$ref": "#/definitions/Country"
        }
      },
      "required": [
        "countrySlug",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "latitude",
        "longitude",
        "name",
        "operationName",
        "population",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "Country": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "continent": {
          "type": "string"
        },
        "subContinent": {
          "type": "string"
        },
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        },
        "polygons": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Polygon"
          }
        }
      },
      "required": [
        "continent",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "latitude",
        "longitude",
        "name",
        "operationName",
        "polygons",
        "projectRelativePath",
        "slug",
        "subContinent",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "DistantObject": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "moon",
            "planet",
            "star",
            "blackHole",
            "asteroid",
            "galaxy"
          ]
        },
        "position": {
          "$ref": "#/definitions/SpacePosition"
        }
      },
      "required": [
        "type",
        "position"
      ],
      "additionalProperties": false
    },
    "Location": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        },
        "parent_locationSlug": {
          "$ref": "#/definitions/Slug"
        },
        "parent_location": {
          "$ref": "#/definitions/Location"
        }
      },
      "additionalProperties": false,
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "projectRelativePath",
        "slug"
      ],
      "description": "locations are hierarchically categorized pieces of information.\n\na city can refer to the area, the area can refer the the country, the country to the continent, etc.\n\nthere are multiple ways to categorize it, but this depends on the application."
    },
    "Polygon": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Position"
      }
    },
    "Position": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        }
      },
      "required": [
        "latitude",
        "longitude"
      ],
      "additionalProperties": false
    },
    "SpacePosition": {
      "description": "IDK HOW TO DO DIS :("
    },
    "NamedParameters%3Ctypeof getAllOperationSourcePaths%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getImportedDependencies%3E": {
      "type": "object",
      "properties": {
        "{\n  operationFolderPath,\n}": {
          "type": "object",
          "properties": {
            "operationFolderPath": {
              "type": "string"
            }
          },
          "required": [
            "operationFolderPath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationFolderPath,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPackage%3E": {
      "type": "object",
      "properties": {
        "absoluteModuleString": {
          "type": "string"
        }
      },
      "required": [
        "absoluteModuleString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isAbsoluteImport%3E": {
      "type": "object",
      "properties": {
        "moduleString": {
          "type": "string"
        }
      },
      "required": [
        "moduleString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof calculatePackageJsonDependencies%3E": {
      "type": "object",
      "properties": {
        "dependencies": {
          "$ref": "#/definitions/PackageInfoObject",
          "description": "Current dependencies object in your operation"
        },
        "imports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Creation%3CTsImport%3E"
          },
          "description": "All imports found in your operation"
        },
        "packageJsons": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PackageJson"
          },
          "description": "All package-json's in your monorepo"
        },
        "operationName": {
          "type": "string"
        }
      },
      "required": [
        "imports",
        "packageJsons",
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAndWriteImportsExports%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        },
        "manualProjectRoot": {
          "type": "string",
          "description": "Manual project root of the operation where the imports and exports needs to be detected and written to database"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getImportsExportsTest%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPackageNameFromAbsoluteImport%3E": {
      "type": "object",
      "properties": {
        "absoluteImportName": {
          "type": "string"
        }
      },
      "required": [
        "absoluteImportName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isAbsoluteImportBuiltin%3E": {
      "type": "object",
      "properties": {
        "absoluteImportName": {
          "type": "string"
        }
      },
      "required": [
        "absoluteImportName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isImportFromOptionalFile%3E": {
      "type": "object",
      "properties": {
        "tsImport": {
          "$ref": "#/definitions/Creation%3CTsImport%3E"
        }
      },
      "required": [
        "tsImport"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof writeResult%3E": {
      "type": "object",
      "properties": {
        "options": {
          "type": "object",
          "properties": {
            "operationName": {
              "type": "string"
            },
            "success": {
              "type": "boolean"
            },
            "message": {
              "type": "string"
            },
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "required": [
            "operationName",
            "success",
            "message"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "options"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationBins%3E": {
      "type": "object",
      "properties": {
        "operationFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "operationFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationPackageName%3E": {
      "type": "object",
      "properties": {
        "operationFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "operationFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPackageJson%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "operationFolderPath": {
              "type": "string"
            }
          },
          "required": [
            "operationFolderPath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPackageSourcePaths%3E": {
      "type": "object",
      "properties": {
        "{\n  operationBasePath,\n  ignoreIndexFiles,\n  allTypes,\n}": {
          "type": "object",
          "properties": {
            "operationBasePath": {
              "type": "string"
            },
            "ignoreIndexFiles": {
              "type": "boolean"
            },
            "allTypes": {
              "type": "boolean",
              "description": "by default, only searches for ts and tsx files, if this is true, it will search for any type"
            }
          },
          "required": [
            "operationBasePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationBasePath,\n  ignoreIndexFiles,\n  allTypes,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findOperationBasePath%3E": {
      "type": "object",
      "properties": {
        "startPath": {
          "type": "string"
        }
      },
      "required": [
        "startPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findOperationBasePathWithClassification%3E": {
      "type": "object",
      "properties": {
        "startPath": {
          "type": "string"
        }
      },
      "required": [
        "startPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllPackageJsonDependencies%3E": {
      "type": "object",
      "properties": {
        "p": {
          "$ref": "#/definitions/PackageJson"
        }
      },
      "required": [
        "p"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getCommonAncestor%3E": {
      "type": "object",
      "properties": {
        "path1": {
          "type": "string"
        },
        "path2": {
          "type": "string"
        }
      },
      "required": [
        "path1",
        "path2"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationClassification%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        }
      },
      "required": [
        "folderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationPath%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string",
          "description": "specify the operation folder name"
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "notUseSdk": {
              "type": "boolean",
              "description": "if true, will not use sdk (defaults to using it first...)"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationPathParse%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationRelativePath%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        },
        "operationBasePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath",
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPathParse%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPathsWithOperations%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string",
              "description": "if given, this will be taken as the project root instead of the one that can be found automatically (useful for bundling or working with multiple projects that alter each other)"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getProjectRoot%3E": {
      "type": "object",
      "properties": {
        "fullSourcePath": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getRelativeLinkPath%3E": {
      "type": "object",
      "properties": {
        "absoluteFromFilePath": {
          "type": "string"
        },
        "absoluteToFilePath": {
          "type": "string"
        },
        "debug": {
          "type": "boolean"
        }
      },
      "required": [
        "absoluteFromFilePath",
        "absoluteToFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getRelativePath%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        },
        "relativeFrom": {
          "type": "string",
          "const": "project-root"
        }
      },
      "required": [
        "absolutePath",
        "relativeFrom"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSrcRelativeFileId%3E": {
      "type": "object",
      "properties": {
        "operationRelativePath": {
          "type": "string"
        }
      },
      "required": [
        "operationRelativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof hasDependency%3E": {
      "type": "object",
      "properties": {
        "packageJson": {
          "$ref": "#/definitions/PackageJson"
        },
        "dependency": {
          "type": "string"
        }
      },
      "required": [
        "packageJson",
        "dependency"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof hasProjectRootFile%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isOperation%3E": {
      "type": "object",
      "properties": {
        "absoluteFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "absoluteFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isSensibleProject%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isWorkspaceRoot%3E": {
      "type": "object",
      "properties": {
        "folderPath": {
          "type": "string"
        }
      },
      "required": [
        "folderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeRelative%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string",
          "description": "absolute path of a file or folder without a slash at the end"
        },
        "baseFolderPath": {
          "type": "string",
          "description": "folder path without a slash at the end"
        }
      },
      "required": [
        "absolutePath",
        "baseFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTsConfig%3E": {
      "type": "object",
      "properties": {
        "packageFolder": {
          "type": "string"
        }
      },
      "required": [
        "packageFolder"
      ],
      "additionalProperties": false
    },
    "CommentRange": {
      "type": "object",
      "additionalProperties": false,
      "properties": {}
    },
    "CompleteOperationPathParse": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "filePath": {
          "type": "string"
        },
        "relativeOperationBasePathFromProjectRoot": {
          "type": "string",
          "description": "relative file path from the project-root to the operation (DOES include operation folder)\n\ne.g. /tools/cognition/typescript/index-typescript"
        },
        "operationRelativeTypescriptFilePath": {
          "type": "string",
          "description": "relative file path from the operation src\n\ne.g. general.ts"
        },
        "srcFileId": {
          "type": "string",
          "description": "file id (same as operationRelativeTypescriptFilePath but without extension)\n\ne.g. \"general\"\n\nTODO: figure out if this can be omitted"
        },
        "operationName": {
          "type": "string",
          "description": "operation package.json name"
        },
        "operationFolderName": {
          "type": "string",
          "description": "operation folder name (by convention, must be identical to operationName, but it could have some mistakes)"
        },
        "relativePathFromProjectRoot": {
          "type": "string",
          "description": "relative file or folder path from the project root"
        }
      },
      "required": [
        "filePath",
        "operationFolderName",
        "operationRelativeTypescriptFilePath",
        "relativeOperationBasePathFromProjectRoot",
        "relativePathFromProjectRoot",
        "srcFileId"
      ]
    },
    "Config": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "minify": {
          "type": "boolean"
        },
        "schemaId": {
          "type": "string"
        },
        "tsconfig": {
          "type": "string"
        },
        "expose": {
          "type": "string",
          "enum": [
            "all",
            "none",
            "export"
          ]
        },
        "topRef": {
          "type": "boolean"
        },
        "jsDoc": {
          "type": "string",
          "enum": [
            "none",
            "extended",
            "basic"
          ]
        },
        "sortProps": {
          "type": "boolean"
        },
        "strictTuples": {
          "type": "boolean"
        },
        "skipTypeCheck": {
          "type": "boolean"
        },
        "encodeRefs": {
          "type": "boolean"
        },
        "extraTags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "additionalProperties": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "JSONSchema7": {
      "type": "object",
      "properties": {
        "$id": {
          "type": "string"
        },
        "$ref": {
          "type": "string"
        },
        "$schema": {
          "$ref": "#/definitions/JSONSchema7Version"
        },
        "$comment": {
          "type": "string"
        },
        "$defs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "type": {
          "anyOf": [
            {
              "$ref": "#/definitions/JSONSchema7TypeName"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/JSONSchema7TypeName"
              }
            }
          ]
        },
        "enum": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONSchema7Type"
          }
        },
        "const": {
          "$ref": "#/definitions/JSONSchema7Type"
        },
        "multipleOf": {
          "type": "number"
        },
        "maximum": {
          "type": "number"
        },
        "exclusiveMaximum": {
          "type": "number"
        },
        "minimum": {
          "type": "number"
        },
        "exclusiveMinimum": {
          "type": "number"
        },
        "maxLength": {
          "type": "number"
        },
        "minLength": {
          "type": "number"
        },
        "pattern": {
          "type": "string"
        },
        "items": {
          "anyOf": [
            {
              "$ref": "#/definitions/JSONSchema7Definition"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/JSONSchema7Definition"
              }
            }
          ]
        },
        "additionalItems": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "maxItems": {
          "type": "number"
        },
        "minItems": {
          "type": "number"
        },
        "uniqueItems": {
          "type": "boolean"
        },
        "contains": {
          "$ref": "#/definitions/JSONSchema7"
        },
        "maxProperties": {
          "type": "number"
        },
        "minProperties": {
          "type": "number"
        },
        "required": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "properties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "additionalProperties": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/definitions/JSONSchema7Definition"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          }
        },
        "propertyNames": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "if": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "then": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "else": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "allOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "anyOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "oneOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "not": {
          "$ref": "#/definitions/JSONSchema7Definition"
        },
        "format": {
          "type": "string"
        },
        "contentMediaType": {
          "type": "string"
        },
        "contentEncoding": {
          "type": "string"
        },
        "definitions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/JSONSchema7Definition"
          }
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "default": {
          "$ref": "#/definitions/JSONSchema7Type"
        },
        "readOnly": {
          "type": "boolean"
        },
        "writeOnly": {
          "type": "boolean"
        },
        "examples": {
          "$ref": "#/definitions/JSONSchema7Type"
        }
      },
      "additionalProperties": false
    },
    "MorphInterfaceInfo": {
      "type": "object",
      "properties": {
        "raw": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "isExported": {
          "type": "boolean"
        },
        "hasGeneric": {
          "type": "boolean"
        }
      },
      "required": [
        "raw",
        "name",
        "extensions",
        "isExported",
        "hasGeneric"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof cli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findCommentTypes%3E": {
      "type": "object",
      "properties": {
        "commentWithoutFrontmatter": {
          "type": "string"
        }
      },
      "required": [
        "commentWithoutFrontmatter"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateSchema%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        },
        "morphInterfaceInfo": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MorphInterfaceInfo"
          }
        },
        "namedAbsoluteImportNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "filePath",
        "morphInterfaceInfo",
        "namedAbsoluteImportNames"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDbStorageMethod%3E": {
      "type": "object",
      "properties": {
        "{\n  typeName,\n  frontmatter,\n  extensions,\n}": {
          "type": "object",
          "properties": {
            "typeName": {
              "type": "string"
            },
            "frontmatter": {
              "$ref": "#/definitions/Frontmatter"
            },
            "extensions": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "typeName",
            "frontmatter"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  typeName,\n  frontmatter,\n  extensions,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFrontmatterDbStorageMethod%3E": {
      "type": "object",
      "properties": {
        "parameters": {
          "anyOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/Frontmatter"
            }
          ]
        }
      },
      "required": [
        "parameters"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getIndexId%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "filePath",
        "name"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMaxIndentationDepth%3E": {
      "type": "object",
      "properties": {
        "functionText": {
          "type": "string"
        }
      },
      "required": [
        "functionText"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNumberOfLines%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParametersFromInterfaces%3E": {
      "type": "object",
      "properties": {
        "functionName": {
          "type": "string"
        },
        "interfaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Creation%3CTsInterface%3E"
          }
        }
      },
      "required": [
        "functionName",
        "interfaces"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPossibleRefs%3E": {
      "type": "object",
      "properties": {
        "interfaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Creation%3CTsInterface%3E"
          }
        }
      },
      "required": [
        "interfaces"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSizeSummary%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSpecialExtensionDbStorageMethod%3E": {
      "type": "object",
      "properties": {
        "extensions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getValidatedOperationPathParse%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof hasDefinition%3E": {
      "type": "object",
      "properties": {
        "maybeInterface": {
          "$ref": "#/definitions/MaybeInteface"
        }
      },
      "required": [
        "maybeInterface"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof indexTypescript%3E": {
      "type": "object",
      "properties": {
        "{\n  filePaths,\n  manualProjectRoot,\n}": {
          "type": "object",
          "properties": {
            "filePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "filepaths of files to index. must be files from the same operation."
            },
            "manualProjectRoot": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "filePaths",
            "manualProjectRoot"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  filePaths,\n  manualProjectRoot,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof indexTypescriptFile%3E": {
      "type": "object",
      "properties": {
        "project": {
          "$ref": "#/definitions/Project"
        },
        "file": {
          "$ref": "#/definitions/CompleteOperationPathParse"
        },
        "projectRoot": {
          "type": "string"
        }
      },
      "required": [
        "project",
        "file",
        "projectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeTsComment%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "operationRelativeTypescriptFilePath": {
              "type": "string"
            },
            "commentRange": {
              "$ref": "#/definitions/CommentRange"
            },
            "statementName": {
              "type": "string",
              "description": "if we can give the statement a name, it should be provided here"
            },
            "rawStatement": {
              "type": "string"
            },
            "fileContent": {
              "type": "string",
              "description": "needed for calculating line numbers"
            }
          },
          "required": [
            "operationRelativeTypescriptFilePath",
            "commentRange",
            "rawStatement",
            "fileContent"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof schemaToTsInterface%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        },
        "typeName": {
          "type": "string"
        },
        "schema": {
          "$ref": "#/definitions/Schema"
        },
        "morphInterfaceInfo": {
          "$ref": "#/definitions/MorphInterfaceInfo"
        }
      },
      "required": [
        "filePath",
        "typeName",
        "schema"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tryCreateSchema%3E": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/Config"
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "Project": {
      "type": "object",
      "additionalProperties": false,
      "description": "Project that holds source files."
    },
    "NamedParameters%3Ctypeof concatenate%3E": {
      "type": "object",
      "properties": {
        "letter": {
          "type": "string"
        }
      },
      "required": [
        "letter"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParameterAtLocation%3E": {
      "type": "object",
      "properties": {
        "object": {
          "type": "object"
        },
        "location": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "object",
        "location"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof replaceLastOccurence%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        },
        "searchValue": {
          "type": "string"
        },
        "replaceValue": {
          "type": "string"
        }
      },
      "required": [
        "string",
        "searchValue",
        "replaceValue"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof reverseString%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trimSlashes%3E": {
      "type": "object",
      "properties": {
        "absoluteOrRelativePath": {
          "type": "string"
        }
      },
      "required": [
        "absoluteOrRelativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSimpleJsonString%3E": {
      "type": "object",
      "properties": {
        "json": {
          "$ref": "#/definitions/Json"
        }
      },
      "required": [
        "json"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof dev%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string",
          "description": "manual project root for finding the operations"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof devCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof benchmark%3E": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof exploreOperationFolders%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "basePath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAllDocsFolderPaths%3E": {
      "type": "object",
      "properties": {
        "ignoreOperations": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAllFoldersWithName%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "basePath": {
              "type": "string"
            },
            "folderName": {
              "type": "string"
            },
            "ignoreOperations": {
              "type": "boolean"
            }
          },
          "required": [
            "basePath",
            "folderName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAllPackages%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "basePath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findAllTodoFolderPaths%3E": {
      "type": "object",
      "properties": {
        "basePath": {
          "type": "string"
        },
        "ignoreOperations": {
          "type": "boolean"
        }
      },
      "required": [
        "basePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getArgument%3E": {
      "type": "object",
      "properties": {
        "number": {
          "type": "number"
        }
      },
      "required": [
        "number"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof pathArrayIsOperation%3E": {
      "type": "object",
      "properties": {
        "pathArray": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "pathArray"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof runTestsForOperation%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "writeResultsToIndex": {
          "type": "boolean"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof sum%3E": {
      "type": "object",
      "properties": {
        "a": {
          "type": "number"
        },
        "b": {
          "type": "number"
        }
      },
      "required": [
        "a",
        "b"
      ],
      "additionalProperties": false
    },
    "KeyValueMarkdownParse": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/Frontmatter"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KeyValueMarkdownModelType"
          }
        }
      },
      "required": [
        "parameters",
        "data"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof flattenMarkdownChunks%3E": {
      "type": "object",
      "properties": {
        "markdownChunks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownChunk"
          }
        }
      },
      "required": [
        "markdownChunks"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getKvmdItemsRecursively%3E": {
      "type": "object",
      "properties": {
        "chunk": {
          "$ref": "#/definitions/MarkdownChunk"
        },
        "categoryStackCalculatedUntilNow": {
          "$ref": "#/definitions/CategoryStack"
        }
      },
      "required": [
        "chunk"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParagraphsRecursively%3E": {
      "type": "object",
      "properties": {
        "chunk": {
          "$ref": "#/definitions/MarkdownChunk"
        },
        "categoryStackCalculatedUntilNow": {
          "$ref": "#/definitions/CategoryStack"
        }
      },
      "required": [
        "chunk"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof kvmdDataMap%3E": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KeyValueMarkdownModelType"
          }
        },
        "{\n    keyName,\n    valueName,\n    categoryStackCalculatedName,\n    commentName,\n  }": {
          "type": "object",
          "properties": {
            "keyName": {
              "type": "string",
              "description": "key by default"
            },
            "valueName": {
              "type": "string",
              "description": "value by default"
            },
            "commentName": {
              "type": "string",
              "description": "comment by default"
            },
            "categoryStackCalculatedName": {
              "type": "string",
              "description": "categoryStackCalculated by default"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "data",
        "{\n    keyName,\n    valueName,\n    categoryStackCalculatedName,\n    commentName,\n  }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof kvmdDataToString%3E": {
      "type": "object",
      "properties": {
        "kvmdData": {
          "$ref": "#/definitions/KeyValueMarkdownModelType"
        },
        "previous": {
          "$ref": "#/definitions/KeyValueMarkdownModelType"
        }
      },
      "required": [
        "kvmdData"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof kvmdParseToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "keyValueMarkdownParse": {
          "$ref": "#/definitions/KeyValueMarkdownParse"
        }
      },
      "required": [
        "keyValueMarkdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownStringToKvmdParse%3E": {
      "type": "object",
      "properties": {
        "kvMdString": {
          "type": "string"
        },
        "dbFileLocation": {
          "$ref": "#/definitions/DbFileLocation"
        }
      },
      "required": [
        "kvMdString",
        "dbFileLocation"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseKvmdLine%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "KvmdWord": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        }
      },
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "projectRelativePath",
        "slug"
      ],
      "description": "Should later be migrated to `WordMatrix`"
    },
    "MappedWordMatrix": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/WordMatrix"
          },
          {
            "$ref": "#/definitions/WordMatrix"
          }
        ]
      },
      "properties": {},
      "description": "Mapped Object for performance reasons"
    },
    "MarkdownWord": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      },
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "description": "Should later be migrated to `WordMatrix`"
    },
    "NepaliEnglishTranslationMatrix": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "en": {
          "type": "string"
        },
        "index": {
          "type": "number"
        },
        "ne": {
          "type": "string"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "en",
        "id",
        "index",
        "ne",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "Statement": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "your statement: definition, fact, question, quote"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "type": {
          "type": "string",
          "enum": [
            "definition",
            "fact",
            "question",
            "quote"
          ]
        },
        "url": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "agreement": {
          "type": "number",
          "description": "number [0-1] representing agreement\n\n- 1 meaning 100% agreement\n- 0 means 0% agreement or complete disagreement"
        },
        "importancyCalculated": {
          "type": "number",
          "description": "defaults to 0.5 meaning average importancy this could be either a calculated or set property. could it be calculated on your value hierarchy? not sure if this is practical (yet) but still a very interesting property to have, or somehow calculate."
        },
        "wordSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "A statement can connect to one or more words."
        },
        "words": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Word"
          }
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt",
        "wordSlugs"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      }
    },
    "Text": {
      "type": "string",
      "description": "text can be in multiple formats. most texts in data are probably just text but they can also contain markdown\n---- if there is a data model with just a single text and it is clear from the name of the model what it should be, better call it either text or markdown."
    },
    "TokiPonaMatrix": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "category": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tok": {
          "type": "string"
        },
        "nl": {
          "type": "string"
        },
        "en": {
          "type": "string"
        },
        "np": {
          "type": "string"
        },
        "pt-br": {
          "type": "string"
        },
        "em": {
          "type": "string"
        }
      },
      "required": [
        "category",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "em",
        "id",
        "operationName",
        "projectRelativePath",
        "type",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "DEPRECATED: to be migrated to `WordMatrix`"
    },
    "Translation": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "sourcePath": {
          "type": "string",
          "description": "Not sure if this is needed. Do we need to know where any given translation comes from? It would be a lot of searching otherwise, maybe. Maybe this should even be an array if we want to avoid duplication, but this seems to make everything more complex. Maybe just skip sourcePath for the POC."
        },
        "language": {
          "$ref": "#/definitions/Language"
        },
        "markdown": {
          "$ref": "#/definitions/Markdown"
        },
        "text": {
          "$ref": "#/definitions/Text"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "markdown",
        "operationName",
        "projectRelativePath",
        "sourcePath",
        "text",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "We could have a Translation model that collects any translation for any key for any model for any language. The original source text is still stored in the models itself, and every model has just one language.\n\nIf you want a markdown or text key to be translated, add `{parameter}_TranslationId` to the model. The translation can then be generated on-demand and improved afterwards."
    },
    "Word": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string",
          "description": "The word"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "rank": {
          "type": "number",
          "description": "How common this word is in the english language"
        },
        "usageCountCalculated": {
          "type": "number",
          "description": "amount used across the whole monorepo"
        },
        "english_wordSlug": {
          "$ref": "#/definitions/Slug",
          "description": "if the word isn't in english already, this can be a reference to the english word that represents this word the most"
        },
        "english_word": {
          "$ref": "#/definitions/Word"
        },
        "root_wordSlug": {
          "$ref": "#/definitions/Slug",
          "description": "if the word is a certain conjugation of a root word, this should be a reference to the root word"
        },
        "root_word": {
          "$ref": "#/definitions/Word"
        },
        "common_wordSlug": {
          "$ref": "#/definitions/Slug",
          "description": "if the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only"
        },
        "common_word": {
          "$ref": "#/definitions/Word"
        },
        "tokiPona_wordSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "The closest way to express this word in toki pona terms should be an array (order is important here) of slugs of toki pona words"
        },
        "tokiPona_words": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Word"
          }
        },
        "definition_statementId": {
          "$ref": "#/definitions/Id",
          "description": "If the word is defined, this reference should lead to its definition statement\n\nunlike the word, definition statements are always in english.\n\nThe definitions should only be made of the words that are\n- english\n- most common\n- root"
        },
        "definition_statement": {
          "$ref": "#/definitions/Statement"
        },
        "parameterNameSlug": {
          "$ref": "#/definitions/Slug",
          "description": "if the word is also used as a ParameterName, this will refer to the ParameterName."
        },
        "parameterName": {
          "$ref": "#/definitions/ParameterName"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "The goal of the words model is to provide a definition for every word we use, in any language.\n\nDEPRECATED: Should be replaced with `WordMatrix`"
    },
    "WordCategory": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "description": {
          "$ref": "#/definitions/Markdown"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "description",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Different ways to categorise a word semantically"
    },
    "WordConjucation": {
      "type": "string",
      "enum": [
        "plural",
        "female",
        "male",
        "past",
        "future"
      ],
      "description": "In linguistics, conjugation is the creation of derived forms of a verb from its principal parts by inflection\n\nBesides this, there are also other ways to alter a word to add/change meaning, this should be summed up using this enum."
    },
    "WordInfo": {
      "type": "object",
      "properties": {
        "latin": {
          "type": "string",
          "description": "TITLE: Latin writing (if common)"
        },
        "alternative": {
          "type": "string",
          "description": "TITLE: Alternative writing (if common)"
        },
        "phonetic": {
          "type": "string",
          "description": "TITLE: Phonetic writing\n\nDESCRIPTION: Phonetic writing is used to describe how the word is pronounced"
        },
        "audio": {
          "$ref": "#/definitions/BackendAsset",
          "description": "TITLE: Spoken word\n\nDESCRIPTION: Audio fragment containing the spoken word"
        },
        "examples": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "text": {
                "type": "string"
              },
              "audio": {
                "$ref": "#/definitions/BackendAsset"
              }
            },
            "required": [
              "text",
              "audio"
            ],
            "additionalProperties": false
          },
          "description": "DESCRIPTION: Sentences containing this word"
        }
      },
      "additionalProperties": false
    },
    "WordInfoObject": {
      "type": "object",
      "properties": {
        "english": {
          "$ref": "#/definitions/WordInfo"
        },
        "dutch": {
          "$ref": "#/definitions/WordInfo"
        },
        "nepali": {
          "$ref": "#/definitions/WordInfo"
        },
        "portuguese": {
          "$ref": "#/definitions/WordInfo"
        },
        "brazilian": {
          "$ref": "#/definitions/WordInfo"
        },
        "german": {
          "$ref": "#/definitions/WordInfo"
        },
        "french": {
          "$ref": "#/definitions/WordInfo"
        },
        "spanish": {
          "$ref": "#/definitions/WordInfo"
        },
        "italian": {
          "$ref": "#/definitions/WordInfo"
        },
        "norwegian": {
          "$ref": "#/definitions/WordInfo"
        },
        "swedish": {
          "$ref": "#/definitions/WordInfo"
        },
        "danish": {
          "$ref": "#/definitions/WordInfo"
        },
        "vietnamese": {
          "$ref": "#/definitions/WordInfo"
        },
        "indonesian": {
          "$ref": "#/definitions/WordInfo"
        },
        "southAfrican": {
          "$ref": "#/definitions/WordInfo"
        },
        "tokiPona": {
          "$ref": "#/definitions/WordInfo"
        },
        "hindi": {
          "$ref": "#/definitions/WordInfo"
        },
        "mandarin": {
          "$ref": "#/definitions/WordInfo"
        },
        "arabic": {
          "$ref": "#/definitions/WordInfo"
        },
        "bengali": {
          "$ref": "#/definitions/WordInfo"
        },
        "urdu": {
          "$ref": "#/definitions/WordInfo"
        },
        "japanese": {
          "$ref": "#/definitions/WordInfo"
        },
        "swahili": {
          "$ref": "#/definitions/WordInfo"
        }
      },
      "additionalProperties": false
    },
    "WordMatrix": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug"
        },
        "name": {
          "type": "string",
          "description": "unique name of the word in english (or another one if `language` is specified). Can usually be the word itself..."
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "description": {
          "$ref": "#/definitions/Markdown",
          "description": "Definition of the word (in english)"
        },
        "descriptionAudio": {
          "$ref": "#/definitions/BackendAsset"
        },
        "image": {
          "$ref": "#/definitions/BackendAsset"
        },
        "wordCategorySlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          }
        },
        "wordCategorys": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WordCategory"
          }
        },
        "type": {
          "$ref": "#/definitions/WordType"
        },
        "priorityLevel": {
          "$ref": "#/definitions/WordPriority",
          "description": "Priority level is how important this word is to communicate...\n\n\nTITLE: Priority level (defaults to low)\n\ncritical: toki pona word (top 150) high: top 500 medium: top 2500 low (default): less occurence"
        },
        "rank": {
          "type": "number",
          "description": "TITLE: Rank (How common this word is in the english language?)"
        },
        "usageCountCalculated": {
          "type": "number",
          "description": "amount used across the whole monorepo"
        },
        "conjucations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WordConjucation"
          },
          "description": "All ways the word is conjucated from the root word"
        },
        "root_wordMatrixSlug": {
          "$ref": "#/definitions/Slug",
          "description": "SECTION: Relations to other words...\n\nTITLE: Root word\n\nDESCRIPTION: If the word is a certain conjugation of a root word, this should be a reference to the root word"
        },
        "root_word": {
          "$ref": "#/definitions/WordMatrix"
        },
        "common_wordMatrixSlug": {
          "$ref": "#/definitions/Slug",
          "description": "TITLE: Common Synonym\n\nDESCRIPTION: f the word is a synonym to a more common word, this should be a reference to the more common synonym. This is a 1:1 synonym only"
        },
        "common_wordMatrix": {
          "$ref": "#/definitions/WordMatrix"
        },
        "opposite_wordMatrixSlug": {
          "$ref": "#/definitions/Slug",
          "description": "TITLE: Opposite word\n\nDESCRIPTION: If there's another word that's the complete opposite of this one, you can declare it here"
        },
        "opposite_wordMatrix": {
          "$ref": "#/definitions/WordMatrix"
        },
        "tokiPona_wordMatrixSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "TITLE: Toki-Pona words\n\nDESCRIPTION: The closest way to express this word in toki pona terms.\n\nNB: should be an array (order is important here) of slugs of words containing the \"tk\" property. This needs to be a reference so we can also give information about the individual toki pona words"
        },
        "tokiPona_wordMatrixs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WordMatrix"
          }
        },
        "emoji_wordMatrixSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "TITLE: Emoji Words\n\nThe closest way to express this word in emoji terms should be an array (order is important here) of slugs of words containing \"emoji\" property\n\nThis needs to be a reference so we can also give information about the individual emojis"
        },
        "emoji_wordMatrixs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WordMatrix"
          }
        },
        "emoji": {
          "type": "string",
          "description": "SECTION: Translations\n\nDESCRIPTION: Single emoji describing this word 1:1 (if it are more emojis of multiple words, please use the reference instead)"
        },
        "english": {
          "$ref": "#/definitions/WordInfo"
        },
        "dutch": {
          "$ref": "#/definitions/WordInfo"
        },
        "nepali": {
          "$ref": "#/definitions/WordInfo"
        },
        "portuguese": {
          "$ref": "#/definitions/WordInfo"
        },
        "brazilian": {
          "$ref": "#/definitions/WordInfo"
        },
        "german": {
          "$ref": "#/definitions/WordInfo"
        },
        "french": {
          "$ref": "#/definitions/WordInfo"
        },
        "spanish": {
          "$ref": "#/definitions/WordInfo"
        },
        "italian": {
          "$ref": "#/definitions/WordInfo"
        },
        "norwegian": {
          "$ref": "#/definitions/WordInfo"
        },
        "swedish": {
          "$ref": "#/definitions/WordInfo"
        },
        "danish": {
          "$ref": "#/definitions/WordInfo"
        },
        "vietnamese": {
          "$ref": "#/definitions/WordInfo"
        },
        "indonesian": {
          "$ref": "#/definitions/WordInfo"
        },
        "southAfrican": {
          "$ref": "#/definitions/WordInfo"
        },
        "tokiPona": {
          "$ref": "#/definitions/WordInfo"
        },
        "hindi": {
          "$ref": "#/definitions/WordInfo"
        },
        "mandarin": {
          "$ref": "#/definitions/WordInfo"
        },
        "arabic": {
          "$ref": "#/definitions/WordInfo"
        },
        "bengali": {
          "$ref": "#/definitions/WordInfo"
        },
        "urdu": {
          "$ref": "#/definitions/WordInfo"
        },
        "japanese": {
          "$ref": "#/definitions/WordInfo"
        },
        "swahili": {
          "$ref": "#/definitions/WordInfo"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "description",
        "descriptionAudio",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt",
        "wordCategorySlugs",
        "wordCategorys"
      ],
      "description": "--- dbStorageMethod: jsonMultiple\n---\n\nWordMatrix is a matrix that contains as much information about a word as possible in as many languages as possible. Easy to use for 1:1 translation\n\nBesides the keys that are language-agnostic, for every language `key` (See `Language`), there are multiple keys that are connected to that specific language\n\n- [key]: the latin standard written representation for this word\n- [key]Alternative: the alternative written representation for this word, if any (if the language commonly uses a different script, this can be noted here)\n- [key]Audio: a short audio recording for pronunciation of this word\n- [key]Phonetic: a phonetic representation of pronunciation of this word in this language\n- [key]Examples: An array of examples of usage of this word (can contain both a text and audio)"
    },
    "WordPriority": {
      "type": "string",
      "enum": [
        "critical",
        "high",
        "medium",
        "low"
      ]
    },
    "WordType": {
      "type": "string",
      "enum": [
        "noun",
        "adjective",
        "verb"
      ]
    },
    "NamedParameters%3Ctypeof preIndexLint%3E": {
      "type": "object",
      "properties": {
        "{\n  operationFolderPath,\n}": {
          "type": "object",
          "properties": {
            "operationFolderPath": {
              "type": "string"
            }
          },
          "required": [
            "operationFolderPath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationFolderPath,\n}"
      ],
      "additionalProperties": false
    },
    "GlobalLogConfig": {
      "type": "object",
      "properties": {
        "showDebug": {
          "type": "boolean"
        },
        "showDefault": {
          "type": "boolean"
        },
        "sayTitles": {
          "type": "boolean"
        },
        "logFolder": {
          "type": "string",
          "description": "Folder where logs can be stored. If i can access the caller location this can be the operation db."
        }
      },
      "additionalProperties": false,
      "description": "a logging configuration object that you can set using a file in the root of your operation or project."
    },
    "LogConfig": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "The title of this log. If not given, a title will still be parsed from your message by taking the first sentence."
        },
        "type": {
          "$ref": "#/definitions/LogType",
          "description": "how it should look and feel for the user"
        },
        "customConfig": {
          "$ref": "#/definitions/GlobalLogConfig",
          "description": "Overwrite the global log config"
        }
      },
      "additionalProperties": false
    },
    "LogType": {
      "type": "string",
      "enum": [
        "debug",
        "error",
        "warning",
        "success",
        "important",
        "default"
      ],
      "description": "how should it look and feel?"
    },
    "NamedParameters%3Ctypeof getCallerFileName%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof log%3E": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "the message to be displayed to the user"
        },
        "config": {
          "$ref": "#/definitions/LogConfig",
          "description": "the configuration (optional)"
        },
        "data": {
          "description": "Extra data the user needs to be able to see."
        }
      },
      "required": [
        "message"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseTitle%3E": {
      "type": "object",
      "properties": {
        "markdown": {
          "type": "string"
        }
      },
      "required": [
        "markdown"
      ],
      "additionalProperties": false
    },
    "OperationLogConfig": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/GlobalLogConfig"
        },
        "fileConfig": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/GlobalLogConfig"
          }
        },
        "functionConfig": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/GlobalLogConfig"
          }
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "ProjectLogConfig": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/GlobalLogConfig"
        },
        "operationConfig": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OperationLogConfig"
          }
        }
      },
      "required": [
        "config",
        "operationConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof checkAuthToken%3E": {
      "type": "object",
      "properties": {
        "password": {
          "type": "string"
        }
      },
      "required": [
        "password"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof LoginForm%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof logoutFrontend%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "MailDataFromOptional": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "from": {
          "type": "string",
          "description": "If you don't fill this in, the `OsConfig` default will be used."
        },
        "to": {
          "anyOf": [
            {
              "$ref": "#/definitions/EmailData"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/EmailData"
              }
            }
          ]
        },
        "cc": {
          "anyOf": [
            {
              "$ref": "#/definitions/EmailData"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/EmailData"
              }
            }
          ]
        },
        "bcc": {
          "anyOf": [
            {
              "$ref": "#/definitions/EmailData"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/EmailData"
              }
            }
          ]
        },
        "replyTo": {
          "$ref": "#/definitions/EmailData"
        },
        "sendAt": {
          "type": "number"
        },
        "subject": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "html": {
          "type": "string"
        },
        "content": {
          "anyOf": [
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/MailContent"
              }
            },
            {
              "allOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/MailContent"
                  }
                },
                {
                  "type": "object",
                  "properties": {}
                }
              ]
            }
          ]
        },
        "templateId": {
          "type": "string"
        },
        "personalizations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonalizationData"
          }
        },
        "attachments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttachmentData"
          }
        },
        "ipPoolName": {
          "type": "string"
        },
        "batchId": {
          "type": "string"
        },
        "sections": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "headers": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "category": {
          "type": "string"
        },
        "customArgs": {
          "type": "object"
        },
        "asm": {
          "$ref": "#/definitions/ASMOptions"
        },
        "mailSettings": {
          "$ref": "#/definitions/MailSettings"
        },
        "trackingSettings": {
          "$ref": "#/definitions/TrackingSettings"
        },
        "substitutions": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "substitutionWrappers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "isMultiple": {
          "type": "boolean"
        },
        "dynamicTemplateData": {
          "type": "object"
        },
        "hideWarnings": {
          "type": "boolean"
        },
        "replyToList": {
          "anyOf": [
            {
              "$ref": "#/definitions/EmailJSON"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/EmailJSON"
              }
            }
          ]
        }
      },
      "description": "From is optional for sending an email because it will be filled in by the OsConfig default."
    },
    "NamedParameters%3Ctypeof sendMail%3E": {
      "type": "object",
      "properties": {
        "mailData": {
          "anyOf": [
            {
              "$ref": "#/definitions/MailDataFromOptional"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/MailDataFromOptional"
              }
            }
          ]
        },
        "isMultiple": {
          "type": "boolean"
        }
      },
      "required": [
        "mailData"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeFileType%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "CodeblockMode": {
      "type": "string",
      "enum": [
        "preview",
        "scroll",
        "full"
      ]
    },
    "MarkdownParseRenderConfig": {
      "type": "object",
      "properties": {
        "projectRelativeBaseFolderPath": {
          "type": "string",
          "description": "Folder path where the markdown is supposed to be located.\n\nThis is used for knowing where relative links or assets can be found"
        },
        "projectRelativeMarkdownFilePath": {
          "type": "string",
          "description": "project relative path of the markdown file.\n\nThis is used for knowing where relative links or assets can be found"
        },
        "augmentedWordObject": {
          "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E",
          "description": "Mapped object of `AugmentedWord`s. Used to augment the rendered markdown with tooltips and links showing more information about the augmented words."
        },
        "isStatic": {
          "type": "boolean",
          "description": "If true, the files should come from a static folder. This means the relative references should now become projectRelative. Also see `copyAllRelativeFiles`.\n\nIf not true, we will use the api."
        },
        "isDev": {
          "type": "boolean",
          "description": "If true, we assume not all files are present in the static folder yet. This means we need to use the api."
        },
        "big": {
          "type": "boolean"
        }
      },
      "required": [
        "projectRelativeBaseFolderPath",
        "projectRelativeMarkdownFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getRealSrc%3E": {
      "type": "object",
      "properties": {
        "src": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseRenderConfig"
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getUrlFromRelativeUrl%3E": {
      "type": "object",
      "properties": {
        "relativeUrl": {
          "type": "string"
        },
        "relativeUrlStrategy": {
          "type": "string",
          "enum": [
            "api",
            "static"
          ]
        },
        "projectRelativeBaseFolderPath": {
          "type": "string"
        },
        "projectRelativeMarkdownFilePath": {
          "type": "string"
        }
      },
      "required": [
        "relativeUrl",
        "relativeUrlStrategy",
        "projectRelativeBaseFolderPath",
        "projectRelativeMarkdownFilePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getYoutubeId%3E": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof MarkdownCodeblock%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string"
            },
            "extension": {
              "type": "string"
            },
            "minimalMode": {
              "$ref": "#/definitions/CodeblockMode",
              "description": "If set, this is the mode when minimised"
            },
            "expandedMode": {
              "$ref": "#/definitions/CodeblockMode",
              "description": "If set, this is the mode when expanded"
            },
            "isInitiallyExpanded": {
              "type": "boolean",
              "description": "if true, by default it's expanded"
            },
            "isModeStatic": {
              "type": "boolean",
              "description": "if true, mode cannot be changed"
            }
          },
          "required": [
            "text"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderFrontmatter%3E": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/Frontmatter"
        },
        "config": {
          "type": "object",
          "properties": {
            "renderSpacer": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "parameters"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderMarkdownChunk%3E": {
      "type": "object",
      "properties": {
        "chunk": {
          "$ref": "#/definitions/MarkdownChunk"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseRenderConfig"
        }
      },
      "required": [
        "chunk",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderMarkdownContent%3E": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseRenderConfig"
        }
      },
      "required": [
        "content",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderMarkdownParse%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "$ref": "#/definitions/MarkdownParse"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseRenderConfig"
        }
      },
      "required": [
        "markdownParse",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renderMarkdownTitle%3E": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "level": {
          "type": "number"
        }
      },
      "required": [
        "title",
        "level"
      ],
      "additionalProperties": false
    },
    "MarkdownCodeblock": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "code": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "MarkdownParagraphChunk": {
      "type": "object",
      "properties": {
        "isNewline": {
          "type": "boolean"
        },
        "codeblock": {
          "$ref": "#/definitions/MarkdownCodeblock"
        },
        "text": {
          "type": "string"
        },
        "isBolded": {
          "type": "boolean"
        },
        "isItalic": {
          "type": "boolean"
        },
        "isBackticked": {
          "type": "boolean"
        },
        "reference": {
          "$ref": "#/definitions/MarkdownReference"
        }
      },
      "additionalProperties": false
    },
    "MarkdownParseConfig": {
      "type": "object",
      "properties": {
        "noFinal": {
          "type": "boolean",
          "description": "setting this to true will \n\n- not trim strings in frontmatter"
        },
        "frontmatterSchema": {
          "$ref": "#/definitions/SimplifiedSchema",
          "description": "if you want frontmatter to be parsed in correct shape, add frontmatterSchema"
        }
      },
      "additionalProperties": false
    },
    "MarkdownReference": {
      "type": "object",
      "properties": {
        "alt": {
          "type": "string",
          "description": "Alternate text inside of the reference, if available"
        },
        "path": {
          "type": "string",
          "description": "Absolute path to the refered object"
        },
        "isAsset": {
          "type": "boolean",
          "description": "if true, it's an asset (with !)\n\notherwise, it's a link"
        }
      },
      "required": [
        "path"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getChunkParagraphsRecursively%3E": {
      "type": "object",
      "properties": {
        "chunk": {
          "$ref": "#/definitions/MarkdownChunk"
        }
      },
      "required": [
        "chunk"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getImplicitId%3E": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        }
      },
      "required": [
        "title"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownIntro%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkdownParse"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "markdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownParseParagraphs%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "$ref": "#/definitions/MarkdownParse"
        }
      },
      "required": [
        "markdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownReferencePaths%3E": {
      "type": "object",
      "properties": {
        "markdownString": {
          "type": "string"
        }
      },
      "required": [
        "markdownString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownReferencesFromParagraph%3E": {
      "type": "object",
      "properties": {
        "paragraph": {
          "type": "string"
        }
      },
      "required": [
        "paragraph"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownParseToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "$ref": "#/definitions/MarkdownParse"
        }
      },
      "required": [
        "markdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mdContentParseRecursively%3E": {
      "type": "object",
      "properties": {
        "markdownString": {
          "type": "string"
        },
        "level": {
          "type": "number"
        }
      },
      "required": [
        "markdownString",
        "level"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mdToJsonParse%3E": {
      "type": "object",
      "properties": {
        "markdownString": {
          "type": "string"
        },
        "fileName": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseConfig"
        }
      },
      "required": [
        "markdownString"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseFrontmatterMarkdownString%3E": {
      "type": "object",
      "properties": {
        "markdownWithFrontmatter": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/MarkdownParseConfig"
        }
      },
      "required": [
        "markdownWithFrontmatter"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseMarkdownParagraph%3E": {
      "type": "object",
      "properties": {
        "paragraph": {
          "type": "string"
        }
      },
      "required": [
        "paragraph"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseMdToChunks%3E": {
      "type": "object",
      "properties": {
        "markdownString": {
          "type": "string"
        },
        "level": {
          "type": "number"
        }
      },
      "required": [
        "markdownString",
        "level"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeHeaderPrefix%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "DependantCountObject": {
      "type": "object",
      "properties": {
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        },
        "tsInterface": {
          "$ref": "#/definitions/TsInterface"
        },
        "tsVariable": {
          "$ref": "#/definitions/TsVariable"
        },
        "externalDependantFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "externalDependantFiles"
      ],
      "additionalProperties": false,
      "description": "interface that lets us count the amount of dependant files in different item types"
    },
    "JsonPart": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string"
        },
        "json": {
          "$ref": "#/definitions/Json"
        }
      },
      "required": [
        "json"
      ],
      "additionalProperties": false
    },
    "MergedMarkdownOutlineUrl": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "hashtagPath": {
          "type": "string"
        }
      },
      "required": [
        "title",
        "hashtagPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addDependantCount%3E": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "tsFunction",
            "tsVariable",
            "tsInterface"
          ]
        },
        "imports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsImport"
          }
        }
      },
      "required": [
        "type",
        "imports"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof bundleFolderWithMarkdown%3E": {
      "type": "object",
      "properties": {
        "outlineTitle": {
          "type": "string"
        },
        "absoluteFolderPath": {
          "type": "string"
        },
        "fileName": {
          "type": "string",
          "description": "filename to include in the final MarkdownParse"
        }
      },
      "required": [
        "outlineTitle",
        "absoluteFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof bundleToBookMarkdown%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "bundleConfig": {
              "$ref": "#/definitions/BundleConfig"
            },
            "title": {
              "type": "string"
            },
            "coverImagePath": {
              "type": "string"
            },
            "isModulesIncluded": {
              "type": "boolean"
            },
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "required": [
            "bundleConfig"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof bundleToMarkdown%3E": {
      "type": "object",
      "properties": {
        "{\n  bundleConfigId,\n  includeModules,\n}": {
          "type": "object",
          "properties": {
            "bundleConfigId": {
              "type": "string"
            },
            "includeModules": {
              "type": "boolean",
              "description": "if true, also includes the private modules"
            }
          },
          "required": [
            "bundleConfigId"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  bundleConfigId,\n  includeModules,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof deployToVercel%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof emailMarkdownParse%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateStaticSite%3E": {
      "type": "object",
      "properties": {
        "{\n  projectRelativeMdFilePath,\n  singlePage,\n}": {
          "type": "object",
          "properties": {
            "singlePage": {
              "type": "boolean"
            },
            "projectRelativeMdFilePath": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  projectRelativeMdFilePath,\n  singlePage,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getJsonSchemaSummary%3E": {
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/JSONSchema7"
        },
        "isMarkdown": {
          "type": "boolean"
        }
      },
      "required": [
        "isMarkdown"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMergedMarkdownOutlineUrl%3E": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        }
      },
      "required": [
        "title"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOutline%3E": {
      "type": "object",
      "properties": {
        "markdownParse": {
          "$ref": "#/definitions/MarkdownParse"
        }
      },
      "required": [
        "markdownParse"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTitlesRecursively%3E": {
      "type": "object",
      "properties": {
        "chunk": {
          "$ref": "#/definitions/MarkdownChunk"
        }
      },
      "required": [
        "chunk"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTypeDescriptorRecursive%3E": {
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/JSONSchema7"
        },
        "isMarkdown": {
          "type": "boolean",
          "description": "If true, references will be links, otherwise, just the name of the referred interface"
        }
      },
      "required": [
        "schema",
        "isMarkdown"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isUpperCase%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makeOutlineMarkdownString%3E": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "urls": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MergedMarkdownOutlineUrl"
          }
        }
      },
      "required": [
        "title",
        "urls"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof makePropertiesTable%3E": {
      "type": "object",
      "properties": {
        "properties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SimplifiedSchemaProperty"
          }
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownChunksToMarkdownStringRecursive%3E": {
      "type": "object",
      "properties": {
        "markdownChunks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownChunk"
          }
        }
      },
      "required": [
        "markdownChunks"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownChunkToMarkdownStringRecursive%3E": {
      "type": "object",
      "properties": {
        "markdownChunk": {
          "$ref": "#/definitions/MarkdownChunk"
        }
      },
      "required": [
        "markdownChunk"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownToSayable%3E": {
      "type": "object",
      "properties": {
        "{\n  markdown,\n  markdownFilePath,\n}": {
          "type": "object",
          "properties": {
            "markdownFilePath": {
              "type": "string"
            },
            "markdown": {
              "$ref": "#/definitions/MarkdownParse"
            }
          },
          "required": [
            "markdownFilePath",
            "markdown"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  markdown,\n  markdownFilePath,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mdToPdf%3E": {
      "type": "object",
      "properties": {
        "{\n  absoluteFilePath,\n  markdown,\n  markdownParse,\n  pdfAbsoluteFilePath,\n}": {
          "type": "object",
          "properties": {
            "absoluteFilePath": {
              "type": "string"
            },
            "markdown": {
              "type": "string"
            },
            "markdownParse": {
              "$ref": "#/definitions/MarkdownParse"
            },
            "pdfAbsoluteFilePath": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  absoluteFilePath,\n  markdown,\n  markdownParse,\n  pdfAbsoluteFilePath,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof mergeMarkdownParse%3E": {
      "type": "object",
      "properties": {
        "markdownParses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownParse"
          }
        },
        "fileName": {
          "type": "string"
        }
      },
      "required": [
        "markdownParses"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof noNewlines%3E": {
      "type": "object",
      "properties": {
        "markdown": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof operationRadio%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof operationToMarkdown%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "operationName": {
              "type": "string"
            },
            "manualProjectRoot": {
              "type": "string"
            },
            "isSummary": {
              "type": "boolean",
              "description": "if true, just returns the outline of the operation (function + interface names, size, deps)"
            },
            "mergeDocsInline": {
              "type": "boolean",
              "description": "if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to)"
            },
            "returnType": {
              "type": "string",
              "enum": [
                "parse",
                "string",
                "save"
              ],
              "description": "- save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files\n- string: returns the full markdown string\n- parse: returns the `MarkdownParse`"
            }
          },
          "required": [
            "operationName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof print%3E": {
      "type": "object",
      "properties": {
        "{ absoluteFilePath }": {
          "type": "object",
          "properties": {
            "absoluteFilePath": {
              "type": "string"
            }
          },
          "required": [
            "absoluteFilePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{ absoluteFilePath }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof printNestedTitles%3E": {
      "type": "object",
      "properties": {
        "nestedTitles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NestedTitle"
          }
        },
        "depth": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof projectToMarkdown%3E": {
      "type": "object",
      "properties": {
        "{\n  includeTodo,\n}": {
          "type": "object",
          "properties": {
            "includeTodo": {
              "type": "boolean"
            },
            "includeOperationDetails": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  includeTodo,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof propertyToTableRow%3E": {
      "type": "object",
      "properties": {
        "property": {
          "$ref": "#/definitions/SimplifiedSchemaProperty"
        }
      },
      "required": [
        "property"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof sayablesToMp3%3E": {
      "type": "object",
      "properties": {
        "{\n  sayables,\n  destinationAbsoluteFilePath,\n}": {
          "type": "object",
          "properties": {
            "destinationAbsoluteFilePath": {
              "type": "string"
            },
            "sayables": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Sayable"
              }
            }
          },
          "required": [
            "destinationAbsoluteFilePath",
            "sayables"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  sayables,\n  destinationAbsoluteFilePath,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof selectRandomOperation%3E": {
      "type": "object",
      "properties": {
        "baseFolderPath": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof simplifiedSchemaToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        },
        "name": {
          "type": "string",
          "description": "if not given, no title is printed"
        },
        "isRequired": {
          "type": "boolean"
        },
        "level": {
          "type": "number",
          "description": "the headers level, defaults to 1"
        }
      },
      "required": [
        "isRequired"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tsFunctionToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "tsFunction": {
          "$ref": "#/definitions/TsFunction"
        }
      },
      "required": [
        "tsFunction"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tsInterfaceToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "tsInterface": {
          "$ref": "#/definitions/TsInterface"
        }
      },
      "required": [
        "tsInterface"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tsVariableToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "tsVariable": {
          "$ref": "#/definitions/TsVariable"
        }
      },
      "required": [
        "tsVariable"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof upMarkdownChunkLevelRecursively%3E": {
      "type": "object",
      "properties": {
        "markdownChunks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownChunk"
          }
        }
      },
      "additionalProperties": false
    },
    "NestedTitle": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NestedTitle"
          }
        }
      ]
    },
    "Sayable": {
      "type": "object",
      "properties": {
        "sayableText": {
          "type": "string"
        },
        "voiceFileRelativePath": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "GetStaticPathsContext": {
      "type": "object",
      "properties": {
        "locales": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "defaultLocale": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "GetStaticPropsContext": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/ParsedUrlQuery"
        },
        "preview": {
          "type": "boolean"
        },
        "previewData": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean",
              "const": false
            },
            {
              "type": "object"
            }
          ]
        },
        "locale": {
          "type": "string"
        },
        "locales": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "defaultLocale": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof copyStaticAssets%3E": {
      "type": "object",
      "properties": {
        "markdownReaderPages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownReaderPage"
          }
        },
        "config": {
          "type": "object",
          "properties": {
            "operationName": {
              "type": "string",
              "description": "by default, uses `markdown-reader-web`"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "markdownReaderPages"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof copyStaticAssetsCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllMarkdownReaderPages%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFolderExplorationInfo%3E": {
      "type": "object",
      "properties": {
        "nestedPathObject": {
          "$ref": "#/definitions/NestedPathObject"
        },
        "queryPath": {
          "type": "string"
        },
        "projectRoot": {
          "type": "string"
        }
      },
      "required": [
        "nestedPathObject",
        "queryPath",
        "projectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownModelPages%3E": {
      "type": "object",
      "properties": {
        "projectRoot": {
          "type": "string"
        }
      },
      "required": [
        "projectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownPageInfo%3E": {
      "type": "object",
      "properties": {
        "projectRoot": {
          "type": "string"
        },
        "nestedPathObject": {
          "$ref": "#/definitions/NestedPathObject"
        },
        "queryPath": {
          "type": "string"
        },
        "contentPage": {
          "$ref": "#/definitions/MarkdownReaderPage"
        }
      },
      "required": [
        "projectRoot",
        "nestedPathObject",
        "queryPath",
        "contentPage"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getMarkdownReaderQueryPaths%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationPages%3E": {
      "type": "object",
      "properties": {
        "projectRoot": {
          "type": "string"
        },
        "bundleMarkdownReaderConfig": {
          "$ref": "#/definitions/BundleMarkdownReaderConfig"
        }
      },
      "required": [
        "projectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPublicMarkdownFilePaths%3E": {
      "type": "object",
      "properties": {
        "baseFolderPath": {
          "type": "string"
        },
        "includeFoldersWithResults": {
          "type": "boolean"
        }
      },
      "required": [
        "baseFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTodoPages%3E": {
      "type": "object",
      "properties": {
        "projectRoot": {
          "type": "string"
        }
      },
      "required": [
        "projectRoot"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownReaderGetStaticPaths%3E": {
      "type": "object",
      "properties": {
        "context": {
          "$ref": "#/definitions/GetStaticPathsContext"
        }
      },
      "required": [
        "context"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownReaderGetStaticProps%3E": {
      "type": "object",
      "properties": {
        "context": {
          "$ref": "#/definitions/GetStaticPropsContext"
        }
      },
      "required": [
        "context"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeExtensionsFromPath%3E": {
      "type": "object",
      "properties": {
        "relativePath": {
          "type": "string"
        }
      },
      "required": [
        "relativePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeNumberPrefix%3E": {
      "type": "object",
      "properties": {
        "fileOrFolderName": {
          "type": "string"
        }
      },
      "required": [
        "fileOrFolderName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof shouldExposeMarkdownFile%3E": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/Frontmatter"
        }
      },
      "required": [
        "parameters"
      ],
      "additionalProperties": false
    },
    "NestedPathObject": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/NestedObject"
          },
          {
            "type": "null"
          }
        ]
      },
      "properties": {},
      "description": "A different way to represent a path array in a nested object of folders\n\n{  \"folderName\": {    \"file1\": null,    \"file2\": null  },  \"folderName2\": {    \"file1\": null,    \"file2\": null  } }"
    },
    "AugmentedWordObject": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/AugmentedWord"
      },
      "description": "This datastructure is probably needed to make it more efficient.\n\nShould be a lookup table for the querypath for every word"
    },
    "AugmentedWordTypeEnum": {
      "type": "string"
    },
    "MarkdownReaderPageProps": {
      "type": "object",
      "properties": {
        "publicBundleConfig": {
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "categoryStackCalculated": {
                  "$ref": "#/definitions/CategoryStack",
                  "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
                },
                "id": {
                  "$ref": "#/definitions/Id"
                },
                "operationName": {
                  "type": [
                    "null",
                    "string"
                  ],
                  "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
                },
                "projectRelativePath": {
                  "type": "string",
                  "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
                },
                "operationRelativePath": {
                  "type": "string",
                  "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
                },
                "createdAt": {
                  "$ref": "#/definitions/CreatedAt"
                },
                "updatedAt": {
                  "$ref": "#/definitions/UpdatedAt"
                },
                "deletedAt": {
                  "$ref": "#/definitions/DeletedAt"
                },
                "createdFirstAt": {
                  "$ref": "#/definitions/CreatedFirstAt"
                },
                "slug": {
                  "$ref": "#/definitions/Id"
                },
                "name": {
                  "$ref": "#/definitions/Id"
                },
                "language": {
                  "$ref": "#/definitions/Id"
                },
                "description": {
                  "$ref": "#/definitions/Id"
                },
                "emoji": {
                  "$ref": "#/definitions/Id"
                },
                "primaryColor": {
                  "$ref": "#/definitions/Id"
                },
                "gitRepoUrl": {
                  "$ref": "#/definitions/Id"
                },
                "isGitRepoPublic": {
                  "$ref": "#/definitions/Id"
                },
                "bundleMarkdownReaderConfig": {
                  "$ref": "#/definitions/Id"
                }
              },
              "required": [
                "id",
                "operationName",
                "projectRelativePath",
                "createdAt",
                "updatedAt",
                "deletedAt",
                "createdFirstAt"
              ],
              "additionalProperties": false
            },
            {
              "type": "null"
            }
          ]
        },
        "projectRelativeMarkdownPath": {
          "type": [
            "string",
            "null"
          ]
        },
        "augmentedWordObject": {
          "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
        },
        "markdownFile": {
          "anyOf": [
            {
              "$ref": "#/definitions/WebMarkdownFile"
            },
            {
              "type": "null"
            }
          ],
          "description": "If markdownfile is null, the page should exist, but the reading of the file failed"
        },
        "pages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarkdownReaderPage"
          }
        },
        "title": {
          "type": [
            "string",
            "null"
          ],
          "description": "Title of the page"
        },
        "children": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "title": {
                "type": "string"
              },
              "firstParagraph": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "folderName": {
                "type": "string"
              },
              "projectRelativeMarkdownPath": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "required": [
              "title",
              "firstParagraph",
              "folderName",
              "projectRelativeMarkdownPath"
            ],
            "additionalProperties": false
          },
          "description": "If path is not a markdownfile, will return all children here"
        },
        "previousQueryPath": {
          "type": [
            "string",
            "null"
          ]
        },
        "nextQueryPath": {
          "type": [
            "string",
            "null"
          ]
        },
        "description": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "pages"
      ],
      "additionalProperties": false
    },
    "FrontmatterValue": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        },
        {
          "type": "boolean"
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        {
          "type": "null"
        },
        {
          "not": {}
        }
      ]
    },
    "MarkdownIndex": {
      "type": "object",
      "properties": {
        "detectedLanguage": {
          "type": "string"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "detectedLanguage",
        "labels"
      ],
      "additionalProperties": false,
      "description": "This could hold anything that we can index about a markdown-file\n\nIt should probably also be posted in the markdown file itself as \"downmatter\", if that's a good idea"
    },
    "NamedParameters%3Ctypeof frontmatterParseToString%3E": {
      "type": "object",
      "properties": {
        "frontmatter": {
          "$ref": "#/definitions/Frontmatter"
        }
      },
      "required": [
        "frontmatter"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFrontmatterValueString%3E": {
      "type": "object",
      "properties": {
        "value": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof quotedOrNot%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stringifyNewlines%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof minifyBuild%3E": {
      "type": "object",
      "properties": {
        "{\n  operationName,\n  buildFolderPath,\n}": {
          "type": "object",
          "properties": {
            "operationName": {
              "type": "string"
            },
            "buildFolderPath": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationName,\n  buildFolderPath,\n}"
      ],
      "additionalProperties": false
    },
    "CategoryModelType": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        }
      },
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "projectRelativePath",
        "slug"
      ],
      "description": "--- isDbModel: false\n---\n\nTODO: make this be able to hold more than just the KV. If that's not really needed just throw this away...\n\nSimple recursive data structure for hierarchical categories. Should be used to make any category model\n\nMake sure, when extending this, to provide a reference `xxxSlug` and its content `xxx` as optional parameters to its parent categories.\n\nE.g. for a `CountryCategory`, you should provide `countryCategorySlug` and `countryCategory`"
    },
    "CreatedAt": {
      "$ref": "#/definitions/Time"
    },
    "CreatedFirstAt": {
      "$ref": "#/definitions/Time",
      "description": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important."
    },
    "CsvModelType": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "boolean",
              "null"
            ]
          }
        ]
      },
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ],
      "description": "Use this model for things you want to store in CSV format\n\nTODO: add support for numbers, booleans, null, undefined"
    },
    "DeletedAt": {
      "$ref": "#/definitions/Time"
    },
    "Email": {
      "type": "string"
    },
    "Index": {
      "type": "number",
      "description": "used for md files. index is the line"
    },
    "KvmdLine": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug, used for model compatibility"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        }
      },
      "required": [
        "id",
        "name",
        "slug",
        "comment"
      ],
      "additionalProperties": false,
      "description": "all things that can be parsed from a single line"
    },
    "NamedParameters%3Ctypeof generateId%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generatePassword%3E": {
      "type": "object",
      "properties": {
        "passwordLength": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateRandomString%3E": {
      "type": "object",
      "properties": {
        "length": {
          "type": "number"
        }
      },
      "required": [
        "length"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateTime%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isEmail%3E": {
      "type": "object",
      "properties": {
        "email": {
          "type": "string"
        }
      },
      "required": [
        "email"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof markdownModelTypeToMarkdownString%3E": {
      "type": "object",
      "properties": {
        "markdownModelType": {
          "$ref": "#/definitions/Storing%3CMarkdownModelType%3E"
        }
      },
      "required": [
        "markdownModelType"
      ],
      "additionalProperties": false
    },
    "PhoneNumber": {
      "type": "number",
      "description": "country code without +"
    },
    "RelationType": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "This probably doesn't work, but it would be great if it would. This way I'd like to say that any model can have keys that end with \"Id\". These keys should always refer to Ids from other models. Also, if a model has a key like this, it is inferred that there is also a key without the Id suffix which does or doesn't cointain the actual model specified by the id.\n\nIf this cannot be done in typescript, it can be convention, and we can create a linter for this.\n\nWooh!\n\n``` const relations: RelationType = { helloId: \"hoi\", byeId: \"bye\", }; ```\n\nThe above seems to be working fine, so it IS possible!\n\nTODO: think about it... should the name of the parameter be dependent on the strategy of how the model is stored? Maybe just call it all id, right? We can also make the index a string by just prepending a string to it."
    },
    "ShouldNotBeStored": {
      "type": "string",
      "enum": [
        "operationName",
        "projectRelativePath",
        "operationRelativePath"
      ],
      "description": "Parameters that should not be stored into the database"
    },
    "SlugModelProperties": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        }
      },
      "required": [
        "slug",
        "name",
        "language"
      ],
      "additionalProperties": false
    },
    "Time": {
      "type": "number",
      "description": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()"
    },
    "TimeTypes": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        }
      },
      "required": [
        "createdAt",
        "updatedAt",
        "deletedAt",
        "createdFirstAt"
      ],
      "additionalProperties": false,
      "description": "TimeTypes is often extended with modelTypes."
    },
    "UpdatedAt": {
      "$ref": "#/definitions/Time"
    },
    "Url": {
      "type": "string",
      "description": "valid url, can be validated"
    },
    "NamedParameters%3Ctypeof getAssetInputType%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        },
        "valueType": {
          "$ref": "#/definitions/SimplifiedSchemaType"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getParameterContentType%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isCalculatedParameter%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isGeneratedParameterName%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "PatternMatcher": {
      "type": "object",
      "properties": {
        "pattern": {
          "type": "string"
        },
        "matches": {
          "type": "string"
        },
        "isSingleWord": {
          "type": "boolean",
          "description": "if true, this indicates that all instances of the matched are single words. This makes it possible to use this patternmatcher directly after another patternmatcher without loosing information."
        }
      },
      "required": [
        "pattern",
        "matches"
      ],
      "additionalProperties": false
    },
    "ExpandedObject": {
      "type": "object",
      "additionalProperties": {
        "type": "boolean"
      }
    },
    "NamedParameters%3Ctypeof queryPathsArrayToNestedPathObject%3E": {
      "type": "object",
      "properties": {
        "queryPaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "queryPaths"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof reduceQueryPathsRecursively%3E": {
      "type": "object",
      "properties": {
        "queryPaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "initialValue": {
          "$ref": "#/definitions/NestedPathObject"
        }
      },
      "required": [
        "queryPaths",
        "initialValue"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useExpanded%3E": {
      "type": "object",
      "properties": {
        "queryPath": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NestedObject": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/NestedObject"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "NamedParameters%3Ctypeof getAvailableOperationName%3E": {
      "type": "object",
      "properties": {
        "rootFolderPath": {
          "type": "string"
        },
        "preferredFolderName": {
          "type": "string"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "rootFolderPath",
        "preferredFolderName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationConfig%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "description": {
          "type": "string",
          "description": "If you want to create one, set a description here."
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newOperation%3E": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "config": {
          "type": "object",
          "properties": {
            "type": {
              "$ref": "#/definitions/OperationClassification"
            },
            "operationConfig": {
              "$ref": "#/definitions/OperationConfig",
              "description": "If given, will put this in OPERAITON.md"
            },
            "description": {
              "type": "string"
            },
            "destinationPath": {
              "type": "string",
              "description": "destinationPath without the operation folder itself\n\n\nIf not provided, uses the working directory from where the process was executed + an inferred foldername"
            },
            "manualProjectRoot": {
              "type": "string",
              "description": "folder path (including if given, uses this project root instead of the project root of the executed process"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newOperationCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newOperationWithFiles%3E": {
      "type": "object",
      "properties": {
        "operationConfig": {
          "$ref": "#/definitions/OperationConfig"
        },
        "srcFileContentObject": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "NB: relative paths must be relative to OPERATION ROOT, not src root!"
        },
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string"
            },
            "destinationPath": {
              "type": "string",
              "description": "folder path without the folder name of the package to be created\n\nif given, will place it here, otherwise, will place it in the default location (tools/generated for os projects, packages for sensible projects)"
            },
            "overwriteIfExists": {
              "type": "boolean",
              "description": "if true, overwrites the operation if it already exists. It does this in a way that it does not break the OS very long, because it removes the old one only after the new one has been created. The removal and renaming the new one to this target name happens almost instantaneously"
            },
            "skipYarnInstall": {
              "type": "boolean",
              "description": "if the operation did not exist before, `yarn install` will usually be ran.\n\nIf you want to skip that, set this to `true`"
            },
            "skipYarnBuild": {
              "type": "boolean",
              "description": "skips yarn build if `true`"
            },
            "dryrun": {
              "type": "boolean",
              "description": "don't write anything, just return the files to create with the strings"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "operationConfig",
        "srcFileContentObject"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newTemplate%3E": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "destinationPath": {
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof newTemplateCli%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof nodemon%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "cliFunctionName": {
          "type": "string",
          "description": "name of the function that you want to run the cli from\n\nby convention, we are going to execute the `build/cli/[fnName].cli.js` file"
        },
        "vars": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "vars that need to be passed to the cli"
        },
        "manualProjectRoot": {
          "type": "string",
          "description": "manual project root for the operation to run"
        }
      },
      "required": [
        "operationName",
        "cliFunctionName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getDependenciesSummary%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getOperationMetaData%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string",
          "description": "any path in an operation"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof writeKeyToOperationIndexJson%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string",
          "description": "can be a path to any file in the operation"
        }
      },
      "required": [
        "absolutePath",
        "key",
        "value"
      ],
      "additionalProperties": false
    },
    "OperationMetaData": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        },
        "operationIndex": {
          "$ref": "#/definitions/OperationIndex"
        },
        "operationName": {
          "type": "string"
        },
        "srcPath": {
          "type": "string"
        },
        "operationFolderName": {
          "type": "string"
        },
        "relativeOperationLocationPath": {
          "type": "string",
          "description": "where the operation is located relative to the project root"
        }
      },
      "required": [
        "operationBasePath",
        "operationName",
        "srcPath",
        "operationFolderName",
        "relativeOperationLocationPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parsePrimitive%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        },
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parsePrimitiveArray%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parsePrimitiveBoolean%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parsePrimitiveString%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "PrimitiveResult": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        },
        {
          "not": {}
        },
        {
          "type": "number"
        },
        {
          "type": "string"
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      ]
    },
    "NamedParameters%3Ctypeof byteCount%3E": {
      "type": "object",
      "properties": {
        "s": {
          "type": "string"
        }
      },
      "required": [
        "s"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFolderSummary%3E": {
      "type": "object",
      "properties": {
        "categorizedFiles": {
          "$ref": "#/definitions/CategorizedFilePaths"
        }
      },
      "required": [
        "categorizedFiles"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof sumSizeSummary%3E": {
      "type": "object",
      "properties": {
        "filePaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "filePaths"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof calculatePathMetaData%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof categorizeFiles%3E": {
      "type": "object",
      "properties": {
        "{\n  basePath,\n  type,\n  ignoreIndexFiles,\n}": {
          "type": "object",
          "properties": {
            "basePath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "ignoreIndexFiles": {
              "type": "boolean",
              "description": "ignore index files or not"
            },
            "type": {
              "type": "string",
              "enum": [
                "code",
                "data",
                "text"
              ],
              "description": "if given, only search for files of a specific containing data type"
            }
          },
          "required": [
            "basePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  basePath,\n  type,\n  ignoreIndexFiles,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPathMainComment%3E": {
      "type": "object",
      "properties": {
        "absolutePath": {
          "type": "string"
        }
      },
      "required": [
        "absolutePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addPeer%3E": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string"
        },
        "authToken": {
          "type": "string"
        },
        "peerName": {
          "type": "string"
        },
        "force": {
          "type": "boolean",
          "description": "If true, it does not validate the IP to see if it is online and it is authorized..."
        },
        "isMe": {
          "type": "boolean"
        }
      },
      "required": [
        "ip"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addPeerMessage%3E": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "peerSlug": {
          "type": "string"
        }
      },
      "required": [
        "message",
        "peerSlug"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllAppOperations%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFirstEmoji%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getNestedPathObject%3E": {
      "type": "object",
      "properties": {
        "baseFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "baseFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPeerMessages%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPeers%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPeersFromPeersRecursively%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPublicFolderNestedPathObject%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPublicFolderNestedPathObjectFromPeer%3E": {
      "type": "object",
      "properties": {
        "peerSlug": {
          "type": "string"
        }
      },
      "required": [
        "peerSlug"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPublicPeers%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isPortUsed%3E": {
      "type": "object",
      "properties": {
        "port": {
          "type": "number"
        }
      },
      "required": [
        "port"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof lateFetchPeerMessageSync%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof ping%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof proactivePushAddPeerMessage%3E": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "peerSlug": {
          "type": "string"
        }
      },
      "required": [
        "message",
        "peerSlug"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removePeer%3E": {
      "type": "object",
      "properties": {
        "slug": {
          "type": "string",
          "description": "Slug of the peer (ip)"
        }
      },
      "required": [
        "slug"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof updatePeer%3E": {
      "type": "object",
      "properties": {
        "slug": {
          "type": "string"
        },
        "updatedValues": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "authToken": {
              "type": "string"
            },
            "isFavorite": {
              "type": "boolean"
            },
            "isMe": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "slug",
        "updatedValues"
      ],
      "additionalProperties": false
    },
    "AppOperation": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "port": {
          "type": "number"
        },
        "description": {
          "type": "string"
        },
        "isOnline": {
          "type": "boolean"
        },
        "emoji": {
          "type": "string",
          "description": "Emoji that should be used as the app icon. Can be calculated from the `OPERATION.md`"
        }
      },
      "required": [
        "name",
        "port"
      ],
      "additionalProperties": false
    },
    "AuthenticationMethod": {
      "type": "object",
      "properties": {
        "method": {
          "$ref": "#/definitions/AuthenticationMethodMethod",
          "description": "NB: Not all are supported yet"
        },
        "handle": {
          "type": "string",
          "description": "most of the time, this is a username, but can also be phone number or email or so"
        },
        "encryptedCredential": {
          "type": "string",
          "description": "This can be a password or token, depending on the method.\n\nIn case of OTP, this isn't required (e.g. for `phoneNumber`)"
        },
        "otp": {
          "type": "number",
          "description": "one time password code, that will be sent to email or sms (or in the future other ways)"
        },
        "isAuthenticated": {
          "type": "boolean",
          "description": "If OTP is not filled in yet, will be false, otherwise true"
        }
      },
      "required": [
        "method",
        "handle",
        "isAuthenticated"
      ],
      "additionalProperties": false
    },
    "AuthenticationMethodMethod": {
      "type": "string",
      "enum": [
        "usernamePassword",
        "phoneNumber",
        "email",
        "apple",
        "google",
        "facebook",
        "twitter",
        "linkedin",
        "github"
      ],
      "description": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored"
    },
    "Device": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string",
          "description": "The ip of the device. Can be a local IP or remote IP.\n\nNB: Port is not included"
        },
        "city": {
          "type": "string"
        },
        "position": {
          "$ref": "#/definitions/Position"
        },
        "positionRadiusKm": {
          "type": "number"
        },
        "country": {
          "type": "string"
        },
        "region": {
          "type": "string"
        },
        "timezone": {
          "type": "string"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "authToken": {
          "type": "string",
          "description": "AuthToken is used to identify a device. Unique identifier that is saved in the devices browser/app.\n\nIf the authToken is the same, we can be sure that the device is matched, even if the IP is different."
        },
        "userAgent": {
          "$ref": "#/definitions/UAParser.IResult",
          "description": "Parsed User Agent header.\n\nNOT used to identify the device, since the device can already be connected to a person!"
        },
        "userAgentString": {
          "type": "string",
          "description": "Raw `User-Agent` header.\n\nNOT used to identify the device, since the device can already be connected to a person!"
        },
        "name": {
          "type": "string",
          "description": "Name of the device, calculated based on metadata like location, os, and ip\n\nCan be edited by the user"
        },
        "previousIps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IPInfo"
          },
          "description": "the root IPInfo is from the latest IP the device had. All previous IPs are added to this array"
        },
        "origins": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Domains the Device has visited\n\nThe Origin request header indicates the origin (scheme, hostname, and port) that caused the request"
        },
        "hasPapi": {
          "type": "boolean",
          "description": "Is set to true if the devices IP is pinged and seems to have something that resembles a King OS PAPI."
        },
        "isOnlineCalculated": {
          "type": "boolean",
          "description": "Returning `true` or `false` indicating whether or not the IP is giving a response"
        },
        "lastOnlineAt": {
          "type": "number",
          "description": "Whenever the peer is online, this should update"
        },
        "isLocalIpCalculated": {
          "type": "boolean",
          "description": "if true, the above IP is a local one, meaning it cannot be accessed from outside of this network\n\nThis is easy to determine: local IP's must start with \"192.168\""
        },
        "isFavorite": {
          "type": "boolean",
          "description": "if `true`, this device will show on top"
        },
        "isPrivate": {
          "type": "boolean",
          "description": "If true, this peer should not be shared"
        },
        "lastSyncDatabaseAtObject": {
          "type": "object",
          "additionalProperties": {
            "type": "number"
          },
          "description": "last sync of any model\n\nUseful for example for a p2p messaging"
        },
        "personIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          },
          "description": "If the device is authenticated, this should be set.\n\nCan be unset by the person"
        },
        "persons": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Person"
          }
        },
        "currentPersonId": {
          "$ref": "#/definitions/Id",
          "description": "A device can switch between persons, by changing this value"
        },
        "appOperationsCalculated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AppOperation"
          },
          "description": "Calculated all operations that can be exposed as apps. This is taken from `getAllAppOperations` function"
        },
        "authenticationMethods": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthenticationMethod"
          },
          "description": "If the `Device` is not identified as a person yet, this can be configured to authenticate with different methods. Once it matches to a person, this can be cleared and `personId` can be attached."
        }
      },
      "required": [
        "authToken",
        "authenticationMethods",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "ip",
        "lastOnlineAt",
        "lastSyncDatabaseAtObject",
        "name",
        "operationName",
        "origins",
        "previousIps",
        "projectRelativePath",
        "updatedAt",
        "userAgent",
        "userAgentString"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "A Device that accesses any King OS api.\n\nA device can be connected to a person. A person can have multiple `Device`s.\n\nA Device does not necissarily have King OS installed themselves, they can also be a visitor to another King OS app of someone else."
    },
    "Group": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string",
          "description": "Name of the group (will set slug)\n\nNB: this can be used in functions to specify certain access to groups. It should there fore be unique and you should be careful when changing it!"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "authorizations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Authorization"
          }
        },
        "amountAuthenticationMethodsRequired": {
          "type": "number",
          "description": "By default, one is enough, but if this is defined, the users in this group need to use this amount of authentication methods before he/she is authenticated. Must be at least one."
        },
        "requiredAuthenticationMethods": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthenticationMethodMethod"
          },
          "description": "Optionally, you can specify which authentication methods are required for the whole group"
        }
      },
      "required": [
        "authorizations",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "A `Person` is able to be part of one or multiple `Group`s.  A `Device` without `Person` is just part of group `unidentified` and can only access `public` info and features. `Group`s and individual `Person`s can be given `Authorization`\n\nFunctions that require authorization can have \n\n`AUTH-[GROUP]: authorization1, authorization2, etc.` in their doc-comment"
    },
    "HandleObject": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      },
      "description": "can be used on multiple models."
    },
    "Interest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        },
        "parent_interestSlug": {
          "$ref": "#/definitions/Slug"
        },
        "parent_interest": {
          "$ref": "#/definitions/Interest"
        }
      },
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "parent_interest",
        "parent_interestSlug",
        "projectRelativePath",
        "slug"
      ],
      "additionalProperties": false
    },
    "MediaCredentail": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "mediaType": {
          "$ref": "#/definitions/MediaPlatformEnum"
        },
        "email": {
          "type": "string"
        },
        "password": {
          "type": "string"
        },
        "username": {
          "type": "string"
        },
        "phoneNumber": {
          "type": "string"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "mediaType",
        "operationName",
        "password",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      }
    },
    "PageVisit": {
      "type": "object",
      "properties": {
        "createdAt": {
          "type": "number",
          "description": "When was the page visited"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "deviceId": {
          "type": "string"
        },
        "path": {
          "type": "string",
          "description": "complete url of the page that was visited"
        },
        "ipInfo": {
          "$ref": "#/definitions/IPInfo"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "deviceId",
        "id",
        "ipInfo",
        "operationName",
        "path",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Any visit tracked based on a server request\n\nNB: TODO: it might occur that a page fetches multiple api endpoints, which will create duplicate data here. How do I fix that?"
    },
    "PeerMessage": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "type": "number",
          "description": "In  this case, this should be the createdAt of the original source! :)"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "peerSlug": {
          "$ref": "#/definitions/Slug",
          "description": "The peer this message has been posted by"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "message",
        "operationName",
        "peerSlug",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "DEPRECTATED: should be replaced by `MediaPost`. MediaPost can  have many channels, and this is just one of them"
    },
    "Person": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "pictureImage": {
          "$ref": "#/definitions/BackendAsset"
        },
        "interestSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "slugs of interest categories that this person should be notified about.\n\nSince this is a hierarchical model, parent interests will ensure all children are also applied."
        },
        "dataEntries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonInformationValue"
          }
        },
        "media": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonSocialMedia"
          },
          "description": "Media that is attached to this person.\n\nNB: not used to authenticate! Can be filled in by King OS, might be erroneous"
        },
        "preferredContactMedium": {
          "$ref": "#/definitions/Slug"
        },
        "devicesCalculated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Device"
          },
          "description": "Devices can be attached to a person by looking in the device model and finding the devices that refer to this person\n\nAmong other things, this can be used to determine the `Person` location"
        },
        "authenticationMethods": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthenticationMethod"
          },
          "description": "Methods that can be used to identify yourself as being this user\n\nShould be set up by the user either when registering, or in settings, to provide more methods.\n\nNB: It's important to note that a `Person` should not be able to add credentials that are already added by another person. This means that, when adding such a method, all `Person`s need to be searched!"
        },
        "groupSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "To which groups does this person belong?\n\nThis determines additional authorizations\n\nCan be set on signup, but can always be edited by admin"
        },
        "groups": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Group"
          }
        },
        "authorizations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Authorization"
          },
          "description": "Which custom authorizations does this `Person` have?"
        },
        "amountAuthenticationMethodsRequired": {
          "type": "number",
          "description": "By default, one is enough, but if this is defined, the user needs to use this amount of authentication methods before he/she is authenticated. Must be at least one"
        },
        "requiredAuthenticationMethods": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AuthenticationMethodMethod"
          },
          "description": "Optionally, the user can setup for themselves which authentication methods they require for themselves to authenticate on another device"
        },
        "credits": {
          "type": "number",
          "description": "Actions by the `Person` can create changes in the amount of credits\n\nThe exact meaning of the number of credits is determined by the OS settings. Can for example be 1:1 to euro, 1:1 to bitcoin, or a custom credit system. Transferability is also customisable.\n\nInsufficient credit can limit the persons possibilities within the OS"
        }
      },
      "required": [
        "authenticationMethods",
        "authorizations",
        "createdAt",
        "createdFirstAt",
        "credits",
        "dataEntries",
        "deletedAt",
        "id",
        "interestSlugs",
        "media",
        "name",
        "operationName",
        "pictureImage",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Model to describe a human person. This model gathers and stores all persons around the world, except for yourself. Kind of a user-like model...\n\n\nThe data inside this model is coming from the `Person` itself but also from the owner of the OS server. It should be possible for the person to automatically push information into any of their instances on any server, but the OS owner can augment this.\n\nNB: This is a `DefaultModelType`, which means name and slug need not to be unique, but it is highly preferred."
    },
    "Persona": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "isPrimary": {
          "type": "boolean",
          "description": "If this is set to true, this persona instance will be selected when searching for a persona. Ensure that there is just one default persona!\n\nIf none are `isPrimary`, the first persona instance can be selected"
        },
        "isFavorite": {
          "type": "boolean",
          "description": "If true, this will pop up in persona selection\n\nIf not, you can still find it using auto-complete, though"
        },
        "pictureImages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BackendAsset"
          },
          "description": "Some pictures that can be used that show this person"
        },
        "dataEntries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonInformationValue"
          },
          "description": "You can give different characteristics to your personas if you wish"
        },
        "interestSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "Interests this persona has\n\nCan be matched against a channel to be the recommended persona"
        },
        "interests": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Interest"
          }
        },
        "locationSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "Where does this persona reside? can be multiple locations\n\nCan be matched against a channel to be the recommended persona"
        },
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Location"
          }
        },
        "spokenLanguages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Language"
          },
          "description": "Languages that this persona can speak\n\nCan be matched against a channel to be the recommended persona"
        },
        "stripeSecret": {
          "type": "string",
          "description": "NB: should have a custom input in the `SimplifiedSchemaForm`"
        },
        "twilioAccountSid": {
          "type": "string"
        },
        "twilioAuthToken": {
          "type": "string"
        },
        "twilioFromPhoneNumber": {
          "type": "string",
          "description": "Provide the phone number you are using by default for sending SMS messages"
        },
        "sendgridApiKey": {
          "type": "string"
        },
        "sendgridFromEmail": {
          "type": "string"
        },
        "githubEmail": {
          "type": "string",
          "description": "Github stuff"
        },
        "githubAccessToken": {
          "type": "string"
        },
        "githubOrganisation": {
          "type": "string"
        },
        "useGithubOrganisation": {
          "type": "boolean"
        },
        "mediaCredentials": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MediaCredentail"
          }
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "dataEntries",
        "deletedAt",
        "id",
        "language",
        "mediaCredentials",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "spokenLanguages",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Highly private model.\n\nConfiguration for a person identity that you say that is you.\n\nAs a OS user you can have multiple personas between which you can easily switch.\n\nThe difference from `Person` is that `Person` stores other people, whereas `Persona` stores different identities you give to yourself.\n\nNB: brands should also be able to be personas, and since some brands are shared between people, you should be able to share Persona's with other `Person`s into their OS...\n\n> Persona: A persona, depending on the context, is the public image of one's personality, the social role that one adopts, or simply a fictional character. The word derives from Latin, where it originally referred to a theatrical mask. On the social web, users develop virtual personas as online identities. (Wikipedia)"
    },
    "PersonInformation": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "same as slug\n\nused for compatibility with some general purpose functions\n\nNB: uniqueness is hard to enforce!"
        },
        "name": {
          "type": "string",
          "description": "key\n\nshould be english because it's kind of part of the codebase!"
        },
        "slug": {
          "type": "string",
          "description": "calculated: slug for this key (kebab case form of the name)"
        },
        "value": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "value behind the semicolom (:). If not given, will be undefined.\n\nIf possible, will be parsed to a number, boolean, null or undefined... otherwise it's a string\n\ncan be any language that we can detect"
        },
        "comment": {
          "type": [
            "string",
            "null"
          ],
          "description": "comment in html syntax. if not given, will be null"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "calculated value that contains the slugs of all preceding categories to this item.\n\nWill be present when fetching from the the db with `fs-orm`"
        },
        "isHeaderCalculated": {
          "type": "boolean",
          "description": "Calculated value indicating whether or not the item has children"
        },
        "parent_personInformationSlug": {
          "$ref": "#/definitions/Slug"
        },
        "parent_personInformation": {
          "$ref": "#/definitions/PersonInformation"
        }
      },
      "additionalProperties": false,
      "required": [
        "categoryStackCalculated",
        "comment",
        "id",
        "isHeaderCalculated",
        "name",
        "operationName",
        "projectRelativePath",
        "slug"
      ],
      "description": "categorisation model for informormation about a person\n\n- the keys are the things you want to store\n- the values are the descriptions of the thing to be stored\n- the categories can organise the things you want to store better"
    },
    "PersonInformationValue": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "operationName",
        "projectRelativePath",
        "updatedAt"
      ],
      "description": "key value data storage model for information about a person\n\n- the filename must identify the person this is about (`personSlug`)\n- the categories are the different people and the person information categories\n- the keys are the person information datapoints\n- the values are the values of the datapoints that you stored about this user\n\nExample:\n\nthe file `person-information-values/abraham-lincoln.md` could contain something like this:\n\n```md # life born: 11-01-1777 died: 20-12-1812\n\n# identification firstName: Abraham lastName: Lincoln ```\n\nNB: It's not going to be easy to keep this model in sync with the model it relies on!\n\nTODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`"
    },
    "PersonPlatformConnection": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "personId": {
          "$ref": "#/definitions/Id",
          "description": "which person"
        },
        "person": {
          "$ref": "#/definitions/Person"
        },
        "isFollow": {
          "type": "boolean",
          "description": "is it a follow, or a connection?"
        },
        "scrapeSucceededAt": {
          "type": [
            "number",
            "null"
          ],
          "description": "when did we last verify and update the connection?"
        },
        "scrapedFailedAt": {
          "type": [
            "number",
            "null"
          ],
          "description": "when did we last try to scrape but failed?"
        },
        "platformSlug": {
          "$ref": "#/definitions/Slug",
          "description": "on which platform"
        },
        "platformConnectionId": {
          "type": "string",
          "description": "how can the connection be identified on that platform?"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "isFollow",
        "operationName",
        "person",
        "personId",
        "platformConnectionId",
        "platformSlug",
        "projectRelativePath",
        "scrapeSucceededAt",
        "scrapedFailedAt",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Forgive the long name, but this model connects the user with the people they have a connection with on specific platforms\n\ne.g. John Doe is connected with me on LinkedIn with the handle `johndoe123`\n\nNot sure if this is the best way to do this, there may be limitations... For example, both I and the other person can have multiple social media accounts on a single platform"
    },
    "PersonSocialMedia": {
      "type": "object",
      "properties": {
        "platformSlug": {
          "$ref": "#/definitions/Slug",
          "description": "medium where the person is a user"
        },
        "path": {
          "type": "string",
          "description": "used to find the user on the platform"
        },
        "isPremium": {
          "type": "boolean",
          "description": "(if available) whether or not the user has a premium account"
        },
        "tagline": {
          "type": "string",
          "description": "(if available) a tagline for the user of the platform"
        },
        "bio": {
          "type": "string",
          "description": "(if available) a bio for the user of the platform"
        }
      },
      "required": [
        "platformSlug",
        "path",
        "isPremium"
      ],
      "additionalProperties": false,
      "description": "media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl"
    },
    "Platform": {
      "type": "object",
      "properties": {
        "slug": {
          "$ref": "#/definitions/Slug",
          "description": "kebab-case of the name, should be unique"
        },
        "name": {
          "type": "string"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "default": "en"
        },
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "userUrlPrefix": {
          "type": "string"
        },
        "userUrlSuffix": {
          "type": "string"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "name",
        "operationName",
        "projectRelativePath",
        "slug",
        "updatedAt",
        "userUrlPrefix",
        "userUrlSuffix"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Collection of platforms that can be found on the internet\n\ne.g. linkedin would have `userUrlPrefix: https://linkedin.com/in/` and `userUrlSuffix:\"\"`"
    },
    "NamedParameters%3Ctypeof getPrimaryPersona%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isPlural%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isSingular%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof pluralize%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof singularize%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTailwindModules%3E": {
      "type": "object",
      "properties": {
        "options": {
          "type": "object",
          "properties": {
            "packages": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "if you are using a sensible monorepo, put the packages with tailwind-based ui here"
            },
            "modules": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "isWorkspace": {
              "type": "boolean",
              "description": "if this is a yarn workspace, put true here"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "options"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof joinClassNames%3E": {
      "type": "object",
      "properties": {
        "args": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "not": {}
              }
            ]
          }
        }
      },
      "required": [
        "args"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Svg%3E": {
      "type": "object",
      "properties": {
        "{ src, width, height, className, style }": {
          "$ref": "#/definitions/SvgType"
        }
      },
      "required": [
        "{ src, width, height, className, style }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trimClassName%3E": {
      "type": "object",
      "properties": {
        "className": {
          "type": "string"
        }
      },
      "required": [
        "className"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof wrapInTextIfNeeded%3E": {
      "type": "object",
      "properties": {
        "children": {},
        "textClassName": {
          "type": "string"
        }
      },
      "required": [
        "children"
      ],
      "additionalProperties": false
    },
    "SvgType": {
      "type": "object",
      "properties": {
        "src": {},
        "width": {
          "type": "number"
        },
        "height": {
          "type": "number"
        },
        "className": {
          "type": "string"
        },
        "style": {}
      },
      "required": [
        "src"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof AlertProvider%3E": {
      "type": "object",
      "properties": {
        "{ children }": {
          "type": "object",
          "properties": {
            "children": {}
          },
          "required": [
            "children"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{ children }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useAlert%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "MapLocation": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        },
        "zoom": {
          "type": "number"
        }
      },
      "required": [
        "latitude",
        "longitude",
        "zoom"
      ],
      "additionalProperties": false
    },
    "PluginInputType": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "description": "universal configuration options of the input"
        },
        "value": {
          "description": "type of the value of the input"
        },
        "extra": {
          "description": "extra possible field specific settings of the input"
        },
        "component": {}
      },
      "required": [
        "value"
      ],
      "additionalProperties": false
    },
    "Suggestion": {
      "type": "object",
      "properties": {
        "bbox": {
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "center": {
          "type": "array",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "id": {
          "type": "string"
        },
        "place_name": {
          "type": "string"
        },
        "place_type": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "text": {
          "type": "string"
        }
      },
      "required": [
        "bbox",
        "center",
        "id",
        "place_name",
        "place_type",
        "text"
      ],
      "additionalProperties": false
    },
    "ViewPort": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "width": {
          "type": [
            "string",
            "number"
          ]
        },
        "height": {
          "type": [
            "string",
            "number"
          ]
        },
        "latitude": {
          "type": "number"
        },
        "longitude": {
          "type": "number"
        },
        "zoom": {
          "type": "number"
        }
      },
      "required": [
        "height",
        "latitude",
        "longitude",
        "width",
        "zoom"
      ]
    },
    "NamedParameters%3Ctypeof Modal%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof ModalProvider%3E": {
      "type": "object",
      "properties": {
        "{ children }": {
          "type": "object",
          "properties": {
            "children": {}
          },
          "required": [
            "children"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{ children }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useModal%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useModalState%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useNavigation%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useRouter%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "ID": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        },
        {
          "not": {}
        }
      ]
    },
    "NamedParameters%3Ctypeof getRealValue%3E": {
      "type": "object",
      "required": [
        "{\n  value,\n  selectFirstOption,\n  options,\n  title,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Select%3E": {
      "type": "object",
      "required": [
        "{\n  options,\n  onChange,\n\n  value,\n  title,\n  containerClassName,\n  selectFirstOption,\n  autoSuggest,\n  //unused atm\n  children,\n  className,\n  noPlaceholder,\n  placeholder,\n  ios,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getItem%3E": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        }
      },
      "required": [
        "key"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof setItem%3E": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {}
      },
      "required": [
        "key",
        "value"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readCsvFile%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readCsvFileSync%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readJsonFile%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readJsonFileSync%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readKvmdFile%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        },
        "dbFileLocation": {
          "$ref": "#/definitions/DbFileLocation",
          "description": "TODO: make this optional. if not provided, calculate it ourselves here."
        }
      },
      "required": [
        "filePath",
        "dbFileLocation"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof readMarkdownFile%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "$ref": "#/definitions/Path"
        }
      },
      "required": [
        "filePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof clearTsDatabase%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof executeCommandQuietUnlessFail%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string"
            },
            "cwd": {
              "type": "string"
            },
            "description": {
              "type": "string",
              "description": "if given, will show what is happening and a checkmark if it succeeds"
            }
          },
          "required": [
            "command"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof exitIfProcessDependenciesChanged%3E": {
      "type": "object",
      "properties": {
        "operationName": {
          "type": "string"
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "operationName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof generateJsonSchemas%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        },
        "operationName": {
          "type": "string",
          "description": "If given, does it just for a single operation"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllDbModels%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        },
        "operationName": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getFileIds%3E": {
      "type": "object",
      "properties": {
        "{\n  operationFolderPath,\n  pathSuffix,\n  extension,\n}": {
          "type": "object",
          "properties": {
            "operationFolderPath": {
              "type": "string"
            },
            "extension": {
              "anyOf": [
                {
                  "$ref": "#/definitions/SearchableExtension"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/SearchableExtension"
                  }
                }
              ]
            },
            "pathSuffix": {
              "type": "string"
            }
          },
          "required": [
            "operationFolderPath",
            "pathSuffix"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  operationFolderPath,\n  pathSuffix,\n  extension,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getIndexFileIds%3E": {
      "type": "object",
      "properties": {
        "operationFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "operationFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSrcIds%3E": {
      "type": "object",
      "properties": {
        "operationFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "operationFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isOperationBuildNeeded%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isSdkOperation%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof rebuildAllOperations%3E": {
      "type": "object",
      "properties": {
        "isRebuildingProcessUpdated": {
          "type": "boolean",
          "description": "If true, you are indicating that the rebuilding process has changed and all operations should be rebuilt after this date."
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof rebuildOperation%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "updatedAt": {
              "type": "number",
              "description": "last date when the rebuild-operation operation was updated (or any of its dependencies)"
            },
            "typerepoManualProjectRoot": {
              "type": "string",
              "description": "If given, uses this as project root for the rebuildOperation dependencies, instead of the calculatable one"
            },
            "operationManualProjectRoot": {
              "type": "string",
              "description": "If given, uses this as project root for finding things from the database for the operation that needs to be rebuilt"
            },
            "operationBasePath": {
              "type": "string",
              "description": "Full path to operation folder or any file therein"
            },
            "filePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "If not given, explores all files in src folder of the operation. if given, must be an array of absolute file paths. it is not supported to index index files, as this creates duplicate and incorrect interfaces."
            },
            "noUnresolvedRebuilding": {
              "type": "boolean",
              "description": "used for stopping recursion"
            },
            "force": {
              "type": "boolean",
              "description": "if true, will not skip if nothing changed"
            },
            "debug": {
              "type": "boolean",
              "description": "show logs"
            },
            "noExit": {
              "type": "boolean",
              "description": "normally, it exits if the operation that was rebuilt was itself or one of its dependencies. Handy for watchOperations in combination with nodemon. If we don't want this behavior, provide noExit"
            },
            "stack": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "stack of recursion of module names"
            }
          },
          "required": [
            "operationBasePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof shouldSkip%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "operationBasePath": {
              "type": "string"
            },
            "debug": {
              "type": "boolean"
            },
            "force": {
              "type": "boolean"
            },
            "operationManualProjectRoot": {
              "type": "string"
            },
            "rebuildUpdatedAt": {
              "type": "number"
            }
          },
          "required": [
            "operationBasePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof yarnBuild%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        },
        "config": {
          "type": "object",
          "properties": {
            "rmFirst": {
              "type": "boolean",
              "description": "if true, build folder will be removed first"
            },
            "skipMinify": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof findTemplates%3E": {
      "type": "object",
      "properties": {
        "basePath": {
          "type": "string"
        },
        "doNotExploreChildFolders": {
          "type": "boolean"
        }
      },
      "required": [
        "basePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isEqualArray%3E": {
      "type": "object",
      "properties": {
        "array1": {
          "type": "array",
          "items": {}
        },
        "array2": {
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "array1",
        "array2"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renameTemplateFiles%3E": {
      "type": "object",
      "properties": {
        "{ appDir }": {
          "type": "object",
          "properties": {
            "appDir": {
              "type": "string"
            }
          },
          "required": [
            "appDir"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{ appDir }"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renameTemplateToNormalFile%3E": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string"
        }
      },
      "required": [
        "fileName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof renameToTemplateFile%3E": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string"
        }
      },
      "required": [
        "fileName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getQueryPart%3E": {
      "type": "object",
      "properties": {
        "strings": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "queryKey": {
          "type": "string"
        }
      },
      "required": [
        "strings",
        "queryKey"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof runChildProcess%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "operationFolderName": {
              "type": "string"
            },
            "scriptFileName": {
              "type": "string",
              "description": "the location of the script in the build folder NB: this must be a CLI that that actually executes the function!"
            },
            "args": {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "not": {}
                  }
                ]
              },
              "description": "all arguments you wish to pass to the script. If an argument is undefined, it will not be passed. Arguments to be passed must be strings"
            }
          },
          "required": [
            "operationFolderName",
            "scriptFileName"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "config"
      ],
      "additionalProperties": false
    },
    "JSONSchema7Definition": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONSchema7"
        },
        {
          "type": "boolean"
        }
      ],
      "description": "JSON Schema v7"
    },
    "NamedParameters%3Ctypeof findFirstCommentTypes%3E": {
      "type": "object",
      "properties": {
        "strippedFullComment": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getPossibleReferenceParameterNames%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getProperties%3E": {
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/Schema",
          "description": "schema type interface we use in TsInterface\n\nNB: don't export because this would make this type exist twice."
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getReferencableModels%3E": {
      "type": "object",
      "properties": {
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getReferenceParameterInfo%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getRefLink%3E": {
      "type": "object",
      "properties": {
        "ref": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSchema%3E": {
      "type": "object",
      "properties": {
        "maybeSchema": {
          "$ref": "#/definitions/JSONSchema7Definition"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSchemaItems%3E": {
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/Schema",
          "description": "schema type interface we use in TsInterface\n\nNB: don't export because this would make this type exist twice."
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof simplifiedSchemaToTypeDefinitionString%3E": {
      "type": "object",
      "properties": {
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof simplifySchema%3E": {
      "type": "object",
      "properties": {
        "name": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the type interface, (this could be used as $ref)."
        },
        "schema": {
          "$ref": "#/definitions/JSONSchema7",
          "description": "The schema that needs to be simplified"
        },
        "possibleRefs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "the name of the schema, (without /definitions/ prefix like $ref)"
              },
              "schema": {
                "$ref": "#/definitions/JSONSchema7"
              }
            },
            "required": [
              "name",
              "schema"
            ],
            "additionalProperties": false
          },
          "description": "The array of other schemas found when crawling file this schema was found in. this also includes all refs to other type interfaces in all schemas in that file"
        },
        "rootStack": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This function is recursive. If we find any reference to another schema, we will add the name of the current schema to the rootStack and explore that schema."
        }
      },
      "required": [
        "name",
        "schema",
        "possibleRefs",
        "rootStack"
      ],
      "additionalProperties": false
    },
    "ReferenceParameterInfo": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        },
        "dataParameterName": {
          "type": "string",
          "description": "If the parameterName is a reference parameter, this will contain the parameterName that should contain the referenced data, should there be one."
        },
        "descriptor": {
          "type": "string"
        },
        "keyInModel": {
          "type": "string"
        },
        "interfaceName": {
          "type": "string"
        },
        "isReferenceMultipleParameter": {
          "type": "boolean"
        },
        "isReferenceSingleParameter": {
          "type": "boolean"
        },
        "isReferenceParameter": {
          "type": "boolean"
        }
      },
      "required": [
        "parameterName",
        "isReferenceMultipleParameter",
        "isReferenceSingleParameter",
        "isReferenceParameter"
      ],
      "additionalProperties": false
    },
    "SchemaItem": {
      "type": "object",
      "properties": {
        "name": {
          "type": [
            "string",
            "null"
          ],
          "description": "name in case of it being a reference, otherwise null"
        },
        "schema": {
          "$ref": "#/definitions/Schema",
          "description": "schema type interface we use in TsInterface\n\nNB: don't export because this would make this type exist twice."
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    },
    "LoginResult": {
      "type": "object",
      "properties": {
        "isSuccessful": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "isSuccessful"
      ],
      "additionalProperties": false
    },
    "LogoutResult": {
      "type": "object",
      "properties": {
        "isSuccessful": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "isSuccessful"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addAuthenticationMethod%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addDeviceAuthenticatedMethod%3E": {
      "type": "object",
      "properties": {
        "deviceId": {
          "type": "string"
        },
        "method": {
          "$ref": "#/definitions/AuthenticationMethodMethod"
        },
        "handle": {
          "type": "string",
          "description": "most of the time, this is a username, but can also be phone number or email or so"
        },
        "credential": {
          "type": "string"
        }
      },
      "required": [
        "deviceId",
        "method",
        "handle"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addDeviceAuthenticationMethodConfirm%3E": {
      "type": "object",
      "properties": {
        "deviceId": {
          "type": "string",
          "description": "device id"
        },
        "method": {
          "$ref": "#/definitions/AuthenticationMethodMethod"
        },
        "otp": {
          "type": "number",
          "description": "one time password"
        }
      },
      "required": [
        "deviceId",
        "method",
        "otp"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof addPersonAuthenticationMethod%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof comparePassword%3E": {
      "type": "object",
      "properties": {
        "rawPassword": {
          "type": "string"
        },
        "encryptedPassword": {
          "type": "string"
        }
      },
      "required": [
        "rawPassword",
        "encryptedPassword"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof encryptPassword%3E": {
      "type": "object",
      "properties": {
        "rawPassword": {
          "type": "string"
        }
      },
      "required": [
        "rawPassword"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isPhoneNumber%3E": {
      "type": "object",
      "properties": {
        "phoneNumber": {
          "type": "string"
        }
      },
      "required": [
        "phoneNumber"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isValidPassword%3E": {
      "type": "object",
      "properties": {
        "password": {
          "type": "string"
        }
      },
      "required": [
        "password"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof login%3E": {
      "type": "object",
      "properties": {
        "deviceId": {
          "type": "string"
        }
      },
      "required": [
        "deviceId"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof logoutPostApi%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removeDeviceAuthenticationMethod%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof removePersonAuthenticationMethod%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof signup%3E": {
      "type": "object",
      "properties": {
        "deviceId": {
          "type": "string"
        },
        "personData": {
          "type": "object",
          "properties": {
            "authorizations": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Authorization"
              },
              "description": "Which custom authorizations does this `Person` have?"
            },
            "credits": {
              "type": "number",
              "description": "Actions by the `Person` can create changes in the amount of credits\n\nThe exact meaning of the number of credits is determined by the OS settings. Can for example be 1:1 to euro, 1:1 to bitcoin, or a custom credit system. Transferability is also customisable.\n\nInsufficient credit can limit the persons possibilities within the OS"
            },
            "dataEntries": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PersonInformationValue"
              }
            },
            "interestSlugs": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Slug"
              },
              "description": "slugs of interest categories that this person should be notified about.\n\nSince this is a hierarchical model, parent interests will ensure all children are also applied."
            },
            "media": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PersonSocialMedia"
              },
              "description": "Media that is attached to this person.\n\nNB: not used to authenticate! Can be filled in by King OS, might be erroneous"
            },
            "name": {
              "type": "string"
            },
            "slug": {
              "type": "string"
            },
            "pictureImage": {
              "$ref": "#/definitions/BackendAsset"
            },
            "groupSlugs": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Slug"
              },
              "description": "To which groups does this person belong?\n\nThis determines additional authorizations\n\nCan be set on signup, but can always be edited by admin"
            },
            "requiredAuthenticationMethods": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AuthenticationMethodMethod"
              },
              "description": "Optionally, the user can setup for themselves which authentication methods they require for themselves to authenticate on another device"
            },
            "amountAuthenticationMethodsRequired": {
              "type": "number",
              "description": "By default, one is enough, but if this is defined, the user needs to use this amount of authentication methods before he/she is authenticated. Must be at least one"
            }
          },
          "required": [
            "authorizations",
            "credits",
            "dataEntries",
            "interestSlugs",
            "media",
            "name",
            "slug",
            "pictureImage"
          ],
          "additionalProperties": false,
          "description": "Data required for creating a `Person`. Can be filled in by the user partly, but also partly automatically"
        }
      },
      "required": [
        "deviceId",
        "personData"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof setJsonKey%3E": {
      "type": "object",
      "properties": {
        "{\n  jsonPath,\n  keyLocation,\n  value,\n  debug,\n}": {
          "type": "object",
          "properties": {
            "jsonPath": {
              "type": "string"
            },
            "keyLocation": {
              "type": "string"
            },
            "value": {
              "type": "string"
            },
            "debug": {
              "type": "boolean"
            }
          },
          "required": [
            "jsonPath",
            "keyLocation",
            "value"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "{\n  jsonPath,\n  keyLocation,\n  value,\n  debug,\n}"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof setKeyAtLocation%3E": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string"
        },
        "value": {},
        "object": {}
      },
      "required": [
        "path",
        "value",
        "object"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getReferencedModelDataItem%3E": {
      "type": "object",
      "properties": {
        "parameterName": {
          "type": "string"
        },
        "referencedModelData": {
          "$ref": "#/definitions/ReferencableModelData"
        }
      },
      "required": [
        "parameterName"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useReferencableModelData%3E": {
      "type": "object",
      "properties": {
        "simplifiedSchema": {
          "$ref": "#/definitions/SimplifiedSchema"
        }
      },
      "required": [
        "simplifiedSchema"
      ],
      "additionalProperties": false
    },
    "ReferencedModelDataItem": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReferenceItem"
          }
        },
        "isLoading": {
          "type": "boolean"
        },
        "parameterName": {
          "type": "string"
        },
        "dataParameterName": {
          "type": "string",
          "description": "If the parameterName is a reference parameter, this will contain the parameterName that should contain the referenced data, should there be one."
        },
        "descriptor": {
          "type": "string"
        },
        "keyInModel": {
          "type": "string"
        },
        "interfaceName": {
          "type": "string"
        },
        "isReferenceMultipleParameter": {
          "type": "boolean"
        },
        "isReferenceSingleParameter": {
          "type": "boolean"
        },
        "isReferenceParameter": {
          "type": "boolean"
        }
      },
      "required": [
        "isReferenceMultipleParameter",
        "isReferenceParameter",
        "isReferenceSingleParameter",
        "parameterName"
      ]
    },
    "ReferenceItem": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack"
        }
      },
      "required": [
        "id"
      ],
      "additionalProperties": false
    },
    "ReferenceItemsObject": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReferenceItem"
          }
        },
        "isLoading": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof sendSms%3E": {
      "type": "object",
      "properties": {
        "options": {
          "type": "object",
          "properties": {
            "addressRetention": {
              "type": "string",
              "const": "retain"
            },
            "applicationSid": {
              "type": "string"
            },
            "attempt": {
              "type": "number"
            },
            "body": {
              "type": "string"
            },
            "contentRetention": {
              "type": "string",
              "const": "retain"
            },
            "contentSid": {
              "type": "string"
            },
            "contentVariables": {
              "type": "string"
            },
            "forceDelivery": {
              "type": "boolean"
            },
            "from": {
              "type": "string"
            },
            "maxPrice": {
              "type": "number"
            },
            "mediaUrl": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "messagingServiceSid": {
              "type": "string"
            },
            "persistentAction": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "provideFeedback": {
              "type": "boolean"
            },
            "scheduleType": {
              "type": "string",
              "const": "fixed"
            },
            "sendAsMms": {
              "type": "boolean"
            },
            "sendAt": {
              "type": "string",
              "format": "date-time"
            },
            "shortenUrls": {
              "type": "boolean"
            },
            "smartEncoded": {
              "type": "boolean"
            },
            "statusCallback": {
              "type": "string"
            },
            "to": {
              "type": "string"
            },
            "validityPeriod": {
              "type": "number"
            }
          },
          "required": [
            "to"
          ],
          "additionalProperties": false,
          "description": "Options to pass to create"
        }
      },
      "required": [
        "options"
      ],
      "additionalProperties": false
    },
    "MediaChannel": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "platformSlug": {
          "$ref": "#/definitions/Slug"
        },
        "platformChannelId": {
          "type": "string",
          "description": "way to identify the channel on the platform"
        },
        "url": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "isGroup": {
          "type": "boolean",
          "description": "if true, this channel is a group"
        },
        "memberPersonIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          },
          "description": "ids that each identify a `Person` that is part of this channel. Isn't always available"
        },
        "interestSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          },
          "description": "group-only: interests this group has"
        },
        "interests": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Interest"
          }
        },
        "locationSlug": {
          "$ref": "#/definitions/Slug",
          "description": "group-only: most specific location of the people in this channel (if any)"
        },
        "location": {
          "$ref": "#/definitions/Location"
        },
        "language": {
          "$ref": "#/definitions/Language",
          "description": "group-only: preferred spoken language in this channel. `Postable` should be translated into this language"
        },
        "mediaCredentialId": {
          "$ref": "#/definitions/Id",
          "description": "Which account do you want to use to post something in this channel?\n\nTODO: maybe refactor this to use `Persona` and match the persona automatically based on interests, location, and language, then get the mediaCredential for the platform from the `Persona` that matches this channel the most..."
        },
        "mediaCredential": {
          "$ref": "#/definitions/MediaCredentail"
        },
        "myLastPostAt": {
          "type": "number",
          "description": "when did you make your last post?"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "language",
        "myLastPostAt",
        "name",
        "operationName",
        "platformChannelId",
        "platformSlug",
        "projectRelativePath",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "channel where messages can be posted to\n\nexamples:\n- facebook group\n- slack channel\n- whatsapp pm\n- facebook pm"
    },
    "MediaPlatformEnum": {
      "type": "string",
      "enum": [
        "facebook",
        "twitter",
        "medium",
        "reddit",
        "devto",
        "linkedin",
        "whatsapp",
        "slack"
      ]
    },
    "MediaPost": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "mediaPlatform": {
          "$ref": "#/definitions/MediaPlatformEnum",
          "description": "Parsed content from the postable content, every social media platform parses in a different way\n\nFor example, a big blog could be parsed into multiple tweets.\n\nAnother example: maybe in some cases we need to remove images or audio\n\nAnother example: markdown is mostly unsupported!"
        },
        "postableId": {
          "type": "string",
          "description": "Id referring to the postable that has been parsed into this MediaPost"
        },
        "postable": {
          "$ref": "#/definitions/Postable"
        },
        "parsedTitle": {
          "type": "string"
        },
        "parsedContent": {
          "type": "string"
        },
        "isPostable": {
          "type": "boolean"
        },
        "unpostableReason": {
          "type": "string"
        },
        "isPosted": {
          "type": "boolean"
        },
        "isVerified": {
          "type": "boolean"
        },
        "postedUrl": {
          "type": "string"
        },
        "channelOrGroup": {
          "type": "string"
        },
        "posted_messageChannelId": {
          "type": "string"
        },
        "posted_messageChannel": {
          "$ref": "#/definitions/MediaChannel"
        },
        "postedDetailsCalculated": {
          "type": "object",
          "properties": {
            "views": {
              "type": "number",
              "description": "URL that leads directly to the posted message"
            },
            "reactions": {
              "type": "number"
            },
            "interactions": {
              "type": "number"
            },
            "statisticsUpdatedAt": {
              "type": "number"
            }
          },
          "required": [
            "views",
            "reactions",
            "interactions",
            "statisticsUpdatedAt"
          ],
          "additionalProperties": false,
          "description": "After it has been posted, this should be filled and frequently updated"
        }
      },
      "required": [
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "isPostable",
        "mediaPlatform",
        "operationName",
        "postableId",
        "projectRelativePath",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          }
        ]
      },
      "description": "Post/message on any medium."
    },
    "NamedParameters%3Ctypeof findPostableToPost%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof updatePostedStatistics%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "Postable": {
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/CreatedAt"
        },
        "updatedAt": {
          "$ref": "#/definitions/UpdatedAt"
        },
        "deletedAt": {
          "$ref": "#/definitions/DeletedAt"
        },
        "createdFirstAt": {
          "$ref": "#/definitions/CreatedFirstAt"
        },
        "operationName": {
          "type": [
            "null",
            "string"
          ],
          "description": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "projectRelativePath": {
          "type": "string",
          "description": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "operationRelativePath": {
          "type": "string",
          "description": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you"
        },
        "id": {
          "$ref": "#/definitions/Id"
        },
        "name": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "slug": {
          "type": "string",
          "description": "filename (slugified)"
        },
        "markdown": {
          "type": "string",
          "description": "the content of the markdown"
        },
        "categoryStackCalculated": {
          "$ref": "#/definitions/CategoryStack",
          "description": "Taken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!"
        },
        "title": {
          "type": "string"
        },
        "isPreset": {
          "type": "boolean",
          "description": "A way to store messagepresets in markdown. the headers are the different categories. If the first alinea is bolded, it will be parsed to be the title, and will be removed from the message."
        },
        "isPlanned": {
          "type": "boolean"
        },
        "isDraft": {
          "type": "boolean"
        },
        "tsInterfaceIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          }
        },
        "tsInterfaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsInterface"
          }
        },
        "tsFunctionIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          }
        },
        "tsFunctions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TsFunction"
          }
        },
        "bundleConfigSlugs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Slug"
          }
        },
        "bundleConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BundleConfig"
          }
        },
        "operationIndexIds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Id"
          }
        },
        "operationIndexs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationIndex"
          }
        },
        "reference_assets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BackendAsset"
          }
        }
      },
      "required": [
        "categoryStackCalculated",
        "createdAt",
        "createdFirstAt",
        "deletedAt",
        "id",
        "markdown",
        "name",
        "operationName",
        "projectRelativePath",
        "reference_assets",
        "slug",
        "updatedAt"
      ],
      "additionalProperties": {
        "anyOf": [
          {
            "description": "This kind of overwrites frontmatter, but it is needed because there need to be models attached to the markdown model sometimes."
          },
          {
            "not": {}
          },
          {
            "$ref": "#/definitions/Id"
          },
          {
            "not": {}
          },
          {
            "type": [
              "string",
              "number",
              "null",
              "boolean",
              "array"
            ]
          }
        ]
      }
    },
    "SocialMediaPostTypeReturnType": {
      "type": "object",
      "properties": {
        "isSuccess": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        },
        "postUrl": {
          "type": "string"
        }
      },
      "required": [
        "isSuccess",
        "message"
      ],
      "additionalProperties": false
    },
    "JSONValue": {
      "anyOf": [
        {
          "type": "null"
        },
        {
          "not": {}
        },
        {
          "type": "boolean"
        },
        {
          "type": "number"
        },
        {
          "type": "string"
        },
        {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/JSONValue"
          }
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JSONValue"
          }
        }
      ]
    },
    "NamedParameters%3Ctypeof objectStringToJson%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parseIfJson%3E": {
      "type": "object",
      "properties": {
        "string": {
          "type": "string"
        }
      },
      "required": [
        "string"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof parsePrimitiveJson%3E": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string"
        }
      },
      "required": [
        "value"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof stringToJson%3E": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string"
        },
        "isObject": {
          "type": "boolean"
        }
      },
      "required": [
        "value"
      ],
      "additionalProperties": false
    },
    "EncodingOpts": {
      "type": "object",
      "properties": {
        "chunkLength": {
          "type": "number",
          "description": "Defaults to 24"
        },
        "chunkBegin": {
          "type": "number",
          "description": "If not provided, will check the start, beginning, and end"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getChunkBegin%3E": {
      "type": "object",
      "properties": {
        "buf": {
          "$ref": "#/definitions/global.Buffer"
        },
        "chunkBegin": {
          "type": "number"
        }
      },
      "required": [
        "buf",
        "chunkBegin"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getChunkEnd%3E": {
      "type": "object",
      "properties": {
        "buf": {
          "$ref": "#/definitions/global.Buffer"
        },
        "chunkEnd": {
          "type": "number"
        }
      },
      "required": [
        "buf",
        "chunkEnd"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getEncoding%3E": {
      "type": "object",
      "properties": {
        "buffer": {
          "anyOf": [
            {
              "$ref": "#/definitions/global.Buffer"
            },
            {
              "type": "null"
            }
          ]
        },
        "opts": {
          "$ref": "#/definitions/EncodingOpts"
        }
      },
      "required": [
        "buffer"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isBinary%3E": {
      "type": "object",
      "properties": {
        "filename": {
          "type": [
            "string",
            "null"
          ],
          "description": "The filename for the file/buffer if available"
        },
        "buffer": {
          "anyOf": [
            {
              "$ref": "#/definitions/global.Buffer"
            },
            {
              "type": "null"
            }
          ],
          "description": "The buffer for the file if available"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isFirstByteOf2ByteChar%3E": {
      "type": "object",
      "properties": {
        "byte": {
          "type": "number"
        }
      },
      "required": [
        "byte"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isFirstByteOf3ByteChar%3E": {
      "type": "object",
      "properties": {
        "byte": {
          "type": "number"
        }
      },
      "required": [
        "byte"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isFirstByteOf4ByteChar%3E": {
      "type": "object",
      "properties": {
        "byte": {
          "type": "number"
        }
      },
      "required": [
        "byte"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isLaterByteOfUtf8%3E": {
      "type": "object",
      "properties": {
        "byte": {
          "type": "number"
        }
      },
      "required": [
        "byte"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isText%3E": {
      "type": "object",
      "properties": {
        "filename": {
          "type": [
            "string",
            "null"
          ],
          "description": "The filename for the file/buffer if available"
        },
        "buffer": {
          "anyOf": [
            {
              "$ref": "#/definitions/global.Buffer"
            },
            {
              "type": "null"
            }
          ],
          "description": "The buffer for the file if available"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof tryParseJson%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        },
        "logParseError": {
          "type": "boolean"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getAllTsMorphSourceFiles%3E": {
      "type": "object",
      "properties": {
        "operationBasePath": {
          "type": "string"
        }
      },
      "required": [
        "operationBasePath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getTsMorphProject%3E": {
      "type": "object",
      "properties": {
        "operationFolderPath": {
          "type": "string"
        }
      },
      "required": [
        "operationFolderPath"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof createCodeblockMarkdown%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        },
        "language": {
          "type": [
            "string",
            "null"
          ],
          "description": "Extension that should be used for color highlighting the text\n\nSet to `null` if you don't want to specify a language\n\ndefaults to \"ts\""
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "CustomUrlStoreConfig": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "string",
            "number",
            "boolean"
          ]
        },
        "isArray": {
          "type": "boolean"
        },
        "allowUndefined": {
          "type": "boolean"
        }
      },
      "required": [
        "type"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof useCustomUrlStore%3E": {
      "type": "object",
      "properties": {
        "queryKey": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/CustomUrlStoreConfig"
        }
      },
      "required": [
        "queryKey",
        "config"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof pickWatcher%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof exitIfOperationsChange%3E": {
      "type": "object",
      "properties": {
        "allOperationSourcePaths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "required": [
        "allOperationSourcePaths"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof gitCommitAllCron%3E": {
      "type": "object",
      "properties": {
        "manualProjectRoot": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof watchOperations%3E": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "manualProjectRoot": {
              "type": "string",
              "description": "manual project root where the operations to watch should be located"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof writeToAssets%3E": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string",
          "description": "Insert `__filename` here or the typescript file path"
        },
        "data": {
          "description": "The data you want to write to a file, can also be a promise"
        },
        "assetsFileName": {
          "type": "string"
        }
      },
      "required": [
        "filePath",
        "data"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Completion%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "augmentedWord": {
              "$ref": "#/definitions/AugmentedWord"
            },
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            }
          },
          "required": [
            "augmentedWord"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof editSubtextSubwordConfig%3E": {
      "type": "object",
      "properties": {
        "subtextConfig": {
          "$ref": "#/definitions/SubtextConfig"
        },
        "subwordConfig": {
          "$ref": "#/definitions/SubwordConfig"
        }
      },
      "required": [
        "subtextConfig",
        "subwordConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getContext%3E": {
      "type": "object",
      "properties": {
        "editorDetails": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string"
            },
            "positionIndex": {
              "type": "number"
            }
          },
          "required": [
            "text",
            "positionIndex"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "editorDetails"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getSubtext%3E": {
      "type": "object",
      "properties": {
        "markdownString": {
          "type": "string",
          "description": "Raw markdown string"
        },
        "subtextConfig": {
          "$ref": "#/definitions/SubtextConfig"
        }
      },
      "required": [
        "markdownString",
        "subtextConfig"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof getWriterTypeFromContent%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isAugmentedWordMatch%3E": {
      "type": "object",
      "properties": {
        "augmentedWord": {
          "$ref": "#/definitions/AugmentedWord"
        },
        "completableWord": {
          "type": "string"
        }
      },
      "required": [
        "augmentedWord",
        "completableWord"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof isTypescript%3E": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof MarkdownCompletions%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "context": {
              "anyOf": [
                {
                  "$ref": "#/definitions/TextEditingContext"
                },
                {
                  "type": "null"
                }
              ]
            },
            "augmentedWords": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AugmentedWord"
              }
            },
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            }
          },
          "required": [
            "context"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof MarkdownParsePresentation%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "markdownParse": {
              "$ref": "#/definitions/MarkdownParse"
            },
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            },
            "projectRelativeBaseFolderPath": {
              "type": "string"
            },
            "projectRelativeMarkdownFilePath": {
              "type": "string"
            }
          },
          "required": [
            "markdownParse",
            "projectRelativeBaseFolderPath",
            "projectRelativeMarkdownFilePath"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof MarkdownView%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "view": {
              "type": "string",
              "enum": [
                "view",
                "presentation"
              ]
            },
            "markdownParse": {
              "$ref": "#/definitions/MarkdownParse"
            },
            "markdownParseRenderConfig": {
              "$ref": "#/definitions/MarkdownParseRenderConfig"
            }
          },
          "required": [
            "view",
            "markdownParse",
            "markdownParseRenderConfig"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof MarkedToken%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "item": {
              "$ref": "#/definitions/marked.Token"
            },
            "subtextConfig": {
              "$ref": "#/definitions/SubtextConfig"
            },
            "subwordConfig": {
              "$ref": "#/definitions/SubwordConfig"
            },
            "markdownFileConfig": {
              "$ref": "#/definitions/MarkdownParseRenderConfig"
            },
            "testModeEnabled": {
              "type": "boolean",
              "description": "If enabled, all content will be tested in realtime"
            }
          },
          "required": [
            "item",
            "subtextConfig",
            "subwordConfig",
            "markdownFileConfig"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof omitSpecialCharactersFromStart%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof SpannedSentence%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "sentence": {
              "type": "string"
            },
            "subtextConfig": {
              "$ref": "#/definitions/SubtextConfig"
            },
            "subwordConfig": {
              "$ref": "#/definitions/SubwordConfig"
            },
            "markdownFileConfig": {
              "$ref": "#/definitions/MarkdownParseRenderConfig"
            },
            "testModeEnabled": {
              "type": "boolean"
            }
          },
          "required": [
            "markdownFileConfig",
            "sentence",
            "subtextConfig",
            "subwordConfig"
          ]
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof SubtextContainer%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "rawMarkdown": {
              "type": "string",
              "description": "raw markdown that should be converted into a subtext"
            },
            "subtextConfig": {
              "$ref": "#/definitions/SubtextConfig"
            }
          },
          "required": [
            "rawMarkdown",
            "subtextConfig"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof Subword%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "word": {
              "type": "string"
            },
            "subwordConfig": {
              "$ref": "#/definitions/SubwordConfig"
            }
          },
          "required": [
            "word",
            "subwordConfig"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof testAllContentEditableRenderComponents%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trimAround%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        },
        "trimLength": {
          "type": "number"
        }
      },
      "required": [
        "word",
        "trimLength"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof trimLeft%3E": {
      "type": "object",
      "properties": {
        "word": {
          "type": "string"
        },
        "character": {
          "type": "string"
        }
      },
      "required": [
        "word",
        "character"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof TypescriptCompletions%3E": {
      "type": "object",
      "properties": {
        "props": {
          "type": "object",
          "properties": {
            "context": {
              "anyOf": [
                {
                  "$ref": "#/definitions/TextEditingContext"
                },
                {
                  "type": "null"
                }
              ]
            },
            "augmentedWords": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AugmentedWord"
              }
            },
            "augmentedWordObject": {
              "$ref": "#/definitions/MappedObject%3CAugmentedWord%3E"
            }
          },
          "required": [
            "context"
          ],
          "additionalProperties": false
        }
      },
      "required": [
        "props"
      ],
      "additionalProperties": false
    },
    "NamedParameters%3Ctypeof WriterConfigForm%3E": {
      "type": "object",
      "additionalProperties": false
    },
    "SubtextConfig": {
      "type": "object",
      "properties": {
        "isEnabled": {
          "type": "boolean",
          "description": "TITLE: Enable"
        },
        "translations": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "language": {
                "$ref": "#/definitions/Language"
              },
              "showAlternative": {
                "type": "boolean"
              },
              "showPhonetic": {
                "type": "boolean"
              },
              "showLatin": {
                "type": "boolean"
              },
              "showTokiPona": {
                "type": "boolean"
              },
              "showCommon": {
                "type": "boolean"
              }
            },
            "required": [
              "language"
            ],
            "additionalProperties": false
          },
          "description": "You can show multiple translations in the subtext"
        },
        "showEmojiTranslation": {
          "type": "boolean"
        },
        "showDefinitionsWithPriority": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WordPriority"
          },
          "description": "show definitions of words occuring in this paragraph"
        },
        "showRelated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SubtextRelatedThing"
          },
          "description": "Related stuff related to this paragraph, e.g. other articles/markdown"
        }
      },
      "additionalProperties": false,
      "description": "Configuration of what should be shown in the subtext"
    },
    "SubwordConfig": {
      "type": "object",
      "properties": {
        "isEnabled": {
          "type": "boolean",
          "description": "TITLE: Enable"
        },
        "subwordSize": {
          "type": "string",
          "enum": [
            "normal",
            "mini",
            "micro"
          ],
          "description": "Optionally, make the subwords smaller for a better overview"
        },
        "translations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Language"
          },
          "description": "show subwords for one or multiple languages"
        },
        "translationsViewMode": {
          "$ref": "#/definitions/SubwordViewMode"
        },
        "showDefinition": {
          "type": "boolean",
          "description": "Show definition (always in tooltip)"
        },
        "occurenceAmountViewMode": {
          "$ref": "#/definitions/SubwordViewMode",
          "description": "Show occurrence amount"
        },
        "blurMode": {
          "type": "string",
          "enum": [
            "disabled",
            "special"
          ],
          "description": "Blur the word unless it's special for one reason or another. Might be useful for skimming (or maybe more)"
        },
        "audioMode": {
          "$ref": "#/definitions/SubwordViewMode",
          "description": "Audio for `WordMatrix` word can be played"
        },
        "replaceWordMode": {
          "type": "string",
          "enum": [
            "disabled",
            "translate",
            "alternative",
            "phonetic",
            "tokiPona",
            "emoji"
          ],
          "description": "if \"translate\" is selected, first language from `translations` will be used\n\n`alternative` picks the alternative writing using the `WordMatrix` if available\n\n`phonetic` picks the phonetic writing using the `WordMatrix` if available"
        },
        "heatmapMode": {
          "type": "string",
          "enum": [
            "disabled",
            "projectFrequency",
            "englishFrequency"
          ],
          "description": "colour words with heat having different meanings"
        }
      },
      "additionalProperties": false,
      "description": "Configurate what should be shown about words"
    },
    "TextEditingContext": {
      "type": "object",
      "properties": {
        "wordAtPosition": {
          "type": "string"
        }
      },
      "required": [
        "wordAtPosition"
      ],
      "additionalProperties": false
    },
    "WriterConfigFormValue": {
      "type": "array",
      "minItems": 2,
      "items": [
        {
          "$ref": "#/definitions/SubtextConfig",
          "title": "subtextConfig"
        },
        {
          "$ref": "#/definitions/SubwordConfig",
          "title": "subwordConfig"
        }
      ],
      "maxItems": 2
    },
    "SubtextRelatedThing": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "image",
            "asset",
            "pages",
            "data",
            "code"
          ]
        },
        "quantity": {
          "type": "string",
          "enum": [
            "single",
            "short",
            "all"
          ]
        }
      },
      "required": [
        "type",
        "quantity"
      ],
      "additionalProperties": false
    },
    "SubwordViewMode": {
      "type": "string",
      "enum": [
        "disabled",
        "tooltip",
        "context",
        "subword"
      ]
    },
    "WriterViewEnum": {
      "type": "string",
      "enum": [
        "config",
        "view",
        "edit",
        "presentation",
        "frontmatter"
      ]
    }
  }
}